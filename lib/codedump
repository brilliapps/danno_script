some not-proffesional code dump 
//import 'package:dart_eval/dart_eval.dart';
import 'dart:async';
import 'dart:isolate';
import 'package:analyzer/dart/analysis/analysis_options.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/type_system.dart';
import 'package:analyzer/dart/constant/value.dart';
import 'package:analyzer_plugin/utilities/navigation/navigation_dart.dart';
import 'package:custom_lint_builder/custom_lint_builder.dart';
import 'dart:io';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/error/error.dart' as errors;
import 'package:analyzer/error/listener.dart';
import 'package:dart_eval/dart_eval_bridge.dart';

/// used by getUltimateNonConditionalNorSwitchExpressions(): when a value is returned,
/// f.e. a Map, depending on this enum value the List may be interpreted
/// as a Map literal (Expression) when UltimateValueType? == Map
/// or as a Map<ComparableUltimateValue, Object> of two optional values representing the same object instance (DartObject and Expression instance) when UltimateValueType.constructorInvokation
/// value origianlly was to be used for comparison with other value of of one of these two types
//enum UltimateValueType {
//  constructorInvokation, map, set,
//}

enum ComparableUltimateValue { dartObject, expression, simple }

class DannoScriptLintsDiscoveryLab extends DartLintRule {
  DannoScriptLintsDiscoveryLab() : super(code: _code);

  // if there were info or warning level messages they didn't display when there were also error level messages. This makes relevant messages error
  final bool msgDebugMode = false;
  final bool displayErrorsOnly = true;
  static const _code = LintCode(
      name: 'anno_types_error',
      problemMessage: 'The ',
      errorSeverity: errors.ErrorSeverity.ERROR);

  int standardNumberOfFields = 100;

  /// An expression may be an Identifier - you cen get from the identifier another identifier or Expression that may be a Literal like ListLiteral or RecordLiteral, (2, 'abc' are also literals but we seek especially $() instance creation).
  /// So this is to get you anything ultimate non Identifier expression
  Expression? getUltimateNonIdentifierExpression(
    ErrorReporter reporter,
    Map<dynamic, List<ReturnStatement>> returnStatements,
    Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId,
    Map<int, List<VariableDeclaration>> variableDeclarationsByElementId,
    Expression expression, [
    // for placing diagnostic or diagnostic-error massages
    Expression? expression2,
    Object? diagnosticMessageNode,
  ]) {
    addLintMessage(
        reporter,
        diagnosticMessageNode ?? expression ?? expression2!,
        msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
        'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.x.1 ');
    if (expression is! Identifier) {
      addLintMessage(
          reporter,
          diagnosticMessageNode ?? expression ?? expression2!,
          msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
          'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.x.2 ');
      return expression;
    }
    while (true) {
      /// value2 - the name is to point that it is to work with the second comparison expression of compareValueFromUltimateExpressionWithAnotherUltimateValue method
      var value2 = getComparableValueFromExpressionOrDartObject(
          reporter,
          returnStatements,
          assignmentExpressionsByElementId,
          variableDeclarationsByElementId,
          expression,
          null,
          expression);
      if (!value2.valueHasBeenFound ||
          value2.value == null ||
          value2.value![ComparableUltimateValue.expression] == null) {
        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.x.3 value2 = ${value2} taken from expression = ${expression} expression.runtimeType = ${expression.runtimeType}  expression.staticType = ${expression.staticType}');
        return null;
      }
      if (value2.value![ComparableUltimateValue.expression] is Identifier) {
        expression =
            value2.value![ComparableUltimateValue.expression] as Identifier;
        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.x.3.5 value2 = ${value2} taken from expression = ${expression} expression.runtimeType = ${expression.runtimeType}  expression.staticType = ${expression.staticType}');
        continue;
      } else {
        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.x.4 ');
        return value2.value![ComparableUltimateValue.expression] as Expression;
      }
    }
  }

  /// Extracting expressions only from param list f.e. abc(1, $(List)), but f.e. [1, $(double), 4] - param expressions is 1, $(double), 4
  bool hasInstanceCreationLikeExpressionAny$Param(
    ErrorReporter reporter,
    Map<dynamic, List<ReturnStatement>> returnStatements,
    Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId,
    Map<int, List<VariableDeclaration>> variableDeclarationsByElementId,
    Expression expression, [
    // for placing diagnostic or diagnostic-error massages
    Expression? expression2,
    Object? diagnosticMessageNode,
  ]) {
    addLintMessage(
        reporter,
        diagnosticMessageNode ?? expression ?? expression2!,
        msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
        'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$()Param part InstanceCreationExpression() second \$() #0.1.1 ');
    List<CollectionElement>? arguments;
    List<Expression> paramExpressions = [];
    if (expression is InstanceCreationExpression) {
      arguments = expression.argumentList.arguments;
    } else if (expression is ListLiteral) {
      arguments = expression.elements;
    } else if (expression is SetOrMapLiteral) {
      arguments = expression.elements;
    } else if (expression is RecordLiteral) {
      arguments = expression.fields;
    }
    if (arguments == null) {
      addLintMessage(
          reporter,
          diagnosticMessageNode ?? expression ?? expression2!,
          msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
          'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.2 ');
      return false;
    }
    for (int k = 0; k < arguments.length; k++) {
      if (arguments[k] is MapLiteralEntry) {
        var key = getUltimateNonIdentifierExpression(
            reporter,
            returnStatements,
            assignmentExpressionsByElementId,
            variableDeclarationsByElementId,
            (arguments[k] as MapLiteralEntry).key,
            null,
            diagnosticMessageNode);
        var value = getUltimateNonIdentifierExpression(
            reporter,
            returnStatements,
            assignmentExpressionsByElementId,
            variableDeclarationsByElementId,
            (arguments[k] as MapLiteralEntry).value,
            null,
            diagnosticMessageNode);

        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.8? key=$key, value=$value');

        if (key is InstanceCreationExpression &&
                key.constructorName.name?.name == '\$' ||
            value is InstanceCreationExpression &&
                value.constructorName.name?.name == '\$') {
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.3 key or value is \$() instance creation');
          return true;
        }
      } else {
        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.4 .arguments[k] = ${arguments[k]}');
        // FIXME: for now reasonably expected to be Expression, never anything else (no if element, spread element)
        var value = getUltimateNonIdentifierExpression(
            reporter,
            returnStatements,
            assignmentExpressionsByElementId,
            variableDeclarationsByElementId,
            arguments[k] as Expression,
            null,
            diagnosticMessageNode);
        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.4.1 value = $value value?.staticType = ${value?.staticType}, value.constructorName.name?.name = ${value is InstanceCreationExpression ? value.constructorName.name?.name : 'value is not an InstanceCreationExpression so has no \$ name,'} value?.staticType?.getDisplayString() == ${value?.staticType?.getDisplayString()}');

        if (value is InstanceCreationExpression &&
            value.staticType != null &&
            (value.staticType?.getDisplayString() == '\$' ||
                value.staticType?.getDisplayString().indexOf('\$<') == 0)) {
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              'compareValueFromUltimateExpressionWithAnotherUltimateValue() calls hasInstanceCreationLikeExpressionAny\$() part InstanceCreationExpression() second \$() #0.1.5 key or value is \$() instance creation');
          return true;
        }
      }
    }
    return false;
  }

  /// Warning! this method can't be called with $M() or $N() and of this exact purposed instances only non-functional expressions.
  /// Compares only a declared variable that had only one value assignment - on declaration or later. If expression(/2) is Identifier() and it returns more than one assignement expressions on calling getComparableValueFromExpressionOrDartObject (yskrn from declaration and/or from possible many assigments) a lint error is shown, but the code smoothly works and doesn't throw Exception.
  /// This means it is ensure that two values compared have no more that one value assignment so the value can be treated as const/final.
  /// Because of this if compareOneTimeAssignmentExpression == false all assignments are used for comparison from more than one element "expressions" sources (one expressions may be one assignment second many assignments or both can be many assignments)
  /// if one comparison fails - error is reported and false is returned
  /// It means on declaration (initializer expression), or on first assignment some time after declaration but with no second or more declarations.
  /// This is necessary to ensure the const/final like nature of the assignment - not neccessary const but you know the value is certain (in standard dart for a method call you can't use the value of the variable that was declared but not initialized with value).
  /// returns true if two computable values are equal like 2.8 == 2.8 or false otherwise.
  /// Warning: is it needed?: returns null if:
  /// 1. an expression is not handled
  /// 2. couldn't find two expressions of the same sort - we can compare two [DartObject]s but no one DartObject and one Expression,
  /// [Edit:] update, currently value for input DartObject returns f.e. DartObject, and expression/s with declaration and all assignments and if you require only one assignment on declaration or later then pass to this method compareOneTimeAssignmentExpression = true;
  /// 3. Possibly (may not be implemented yet) if a difficult expression like function doesn't produce non-null ExecutableElement (like FunctionElement) .staticElement which i guest may mean that any return type or expression was not computable.
  ///    to remind me: also DartObject .toFunctionValue() produces ExecutableElement - with casting or now to function or method element it might be compared too with ==
  bool? compareValueFromUltimateExpressionWithAnotherUltimateValue(
      ErrorReporter reporter,
      Map<dynamic, List<ReturnStatement>> returnStatements,
      Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId,
      Map<int, List<VariableDeclaration>> variableDeclarationsByElementId,
      {Expression? expression,
      DartObject? dartObjectParam,
      bool expressionMustBeConst = true,
      Expression? expression2,
      DartObject? dartObjectParam2,
      // if dartObjectParam2 is supplied (but no expression2):
      DartObject? dartObjectParam2SupportForExpression2,
      // if expression2 is supplied (but no dartObjectParam2):
      Expression? expressionParam2SupportFordartObjectParam2,
      Object? diagnosticMessageNode,
      bool expression2MustBeConst2 = true,
      // If present, to match conditions the expression param must represent simple value and [String] in this case and dartObjectParam2 which is "sort-of" staticly created $R "instance" is not null (not necessary to use expression2) and expression is checked if it matches the regexp
      bool isRegExp = false,
      // If present, If present, to match conditions the expression param must represent simple value and [num] in this case and dartObjectParam2 which is "sort-of" staticly created $B "instance" is not null (not necessary to use expression2) and expression is checked if it matches the $R range object values and other settings.
      bool isBetween = false,
      required MethodDeclaration methodDeclaration}) {
    if (expression != null ||
        expression2 != null ||
        diagnosticMessageNode != null) {
      addLintMessage(
          reporter,
          diagnosticMessageNode ?? expression ?? expression2!,
          msgDebugMode
              ? errors.ErrorSeverity.ERROR
              : errors.ErrorSeverity.WARNING,
          'compareValueFromUltimateExpressionWithAnotherUltimateValue(), WE ENTERED THIS TERRIBLE METHOD !');
    }
    if (expression == null &&
        dartObjectParam == null &&
        (diagnosticMessageNode != null || expression2 != null)) {
      addLintMessage(
          reporter,
          diagnosticMessageNode ?? expression2!,
          errors.ErrorSeverity.ERROR,
          'compareValueFromUltimateExpressionWithAnotherUltimateValue() Error: Can\'t both expression and dartObjectParam be null');
    }
    if (expression2 == null &&
        dartObjectParam2 == null &&
        (diagnosticMessageNode != null || expression != null)) {
      addLintMessage(
          reporter,
          diagnosticMessageNode ?? expression!,
          errors.ErrorSeverity.ERROR,
          'compareValueFromUltimateExpressionWithAnotherUltimateValue() Error: Can\'t both expression2 and dartObjectParam2 be null');
    }

    // ??? We need to provide two ultimate objects ready to be compared whatever they might be.
    // If in the following a key 1: or 2: will could'nt has been found an expression for a given key couldn't for now a way to translated into something easy to compare has been found.
    // now in theory we can compare values starting from easy ones.
    var value = getComparableValueFromExpressionOrDartObject(
        reporter,
        returnStatements,
        assignmentExpressionsByElementId,
        variableDeclarationsByElementId,
        expression,
        dartObjectParam,
        diagnosticMessageNode ?? expression ?? expression2);
    var value2 = getComparableValueFromExpressionOrDartObject(
        reporter,
        returnStatements,
        assignmentExpressionsByElementId,
        variableDeclarationsByElementId,
        expression2,
        dartObjectParam2,
        diagnosticMessageNode ?? expression ?? expression2);

    ({
      Map<ComparableUltimateValue, Object?>? value,
      bool valueHasBeenFound
    })? value2SupportFordartObjectParam2;
    if (expressionParam2SupportFordartObjectParam2 != null) {
      value2SupportFordartObjectParam2 =
          getComparableValueFromExpressionOrDartObject(
              reporter,
              returnStatements,
              assignmentExpressionsByElementId,
              variableDeclarationsByElementId,
              expressionParam2SupportFordartObjectParam2,
              null,
              diagnosticMessageNode ?? expression ?? expression2);
    }

    // Normally if two compared params of this method are DartObject the best is to compare them
    // but if the second param contain expression of a List, Set, Map, Record, class's constructor call (forgot something?),
    // then also if in a param like element we find at least one $() instance call, f.e. [1, $(double), 4], abc(1, $(List)),
    // then no DartObject but Expression must be used and for any $() param-like element the corresponding element from
    // the first expression will be matched against the element from the second expression like normal @$() annotation.
    bool value2HasInstanceCreationLikeExpressionAny$Param = false;

    if (value2.value?[ComparableUltimateValue.expression] is Expression ||
        (value2SupportFordartObjectParam2 != null &&
            value2SupportFordartObjectParam2
                .value?[ComparableUltimateValue.expression] is Expression)) {
      addLintMessage(
          reporter,
          diagnosticMessageNode ?? expression ?? expression2!,
          msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
          'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() second \$() #0.1 ');
      value2HasInstanceCreationLikeExpressionAny$Param =
          hasInstanceCreationLikeExpressionAny$Param(
        reporter,
        returnStatements,
        assignmentExpressionsByElementId,
        variableDeclarationsByElementId,
        value2SupportFordartObjectParam2 != null
            ? value2SupportFordartObjectParam2
                .value![ComparableUltimateValue.expression] as Expression
            : value2.value![ComparableUltimateValue.expression] as Expression,
        expression2,
        diagnosticMessageNode,
      );
    }

    if (expression != null ||
        expression2 != null ||
        diagnosticMessageNode != null) {
      addLintMessage(
          reporter,
          diagnosticMessageNode ?? expression ?? expression2!,
          msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
          '''compareValueFromUltimateExpressionWithAnotherUltimateValue(), we have the following info about compared values:
            expression = ${expression?.toSource()},
            expression?.staticType = ${expression?.staticType}
            expression.runtimeType = ${expression.runtimeType}
            dartObjectParam = $dartObjectParam,
            value = ${value},
            dartObjectParam.variable = ${dartObjectParam?.variable}
            expression2 = ${expression2?.toSource()},
            dartObjectParam2SupportForExpression2 = $dartObjectParam2SupportForExpression2
            expression2?.staticType = ${expression2?.staticType}
            expression2.runtimeType = ${expression2.runtimeType}
            dartObjectParam2 = $dartObjectParam2
            dartObjectParam2.variable = ${dartObjectParam2?.variable}
            value2 = ${value2}
            is value2 to be replaced by a value of value2HasInstanceCreationLikeExpressionAny\$Param = ${(expressionParam2SupportFordartObjectParam2 != null && value2HasInstanceCreationLikeExpressionAny$Param || (expression != null && dartObjectParam == null && expression2 == null && expressionParam2SupportFordartObjectParam2 != null))}
            expressionParam2SupportFordartObjectParam2 = $expressionParam2SupportFordartObjectParam2
            value2SupportFordartObjectParam2 = $value2SupportFordartObjectParam2
            value2HasInstanceCreationLikeExpressionAny\$Param = ${value2HasInstanceCreationLikeExpressionAny$Param}
        ''');
    }

    if (expressionParam2SupportFordartObjectParam2 != null &&
            value2HasInstanceCreationLikeExpressionAny$Param ||
        (expression != null &&
            dartObjectParam == null &&
            expression2 == null &&
            expressionParam2SupportFordartObjectParam2 != null)) {
      value2 = value2SupportFordartObjectParam2!;
    }

    if (value.valueHasBeenFound &&
            (value2.valueHasBeenFound ||
                (!value2.valueHasBeenFound && (isRegExp || isBetween)))
        // FIXME: WHILE FOR value2.isValueTakenFromLiteral producing DartObject, etc. this is reliable as i tested to some degree...
        // BUT FOR OBJECT PRODUCED FROM LITERALS value.isValueTakenFromLiteral = false (NOT NULL!!!) it is yet to be tested and doubtfull it will work unfailingly
        ) {
      if ((isRegExp || isBetween) &&
          value.value?.keys.contains(ComparableUltimateValue.simple) == true) {
        if (isBetween) {
          // final num t1; // left limit value
          // final num t2; // right limit value
          // final bool t3; // must be int-like (may be type double but integer - to enforce can't be double use f.e. @$(num $B(...) $NOT double))
          // final bool t4; // includes left limit value
          // final bool t5; // includes right limit value
          num leftLimitValue =
              dartObjectParam2!.getField('t1')!.toDoubleValue() ??
                  dartObjectParam2.getField('t1')!.toIntValue()!;
          num rightLimitValue =
              dartObjectParam2.getField('t2')!.toDoubleValue() ??
                  dartObjectParam2.getField('t2')!.toIntValue()!;

          if (leftLimitValue >= rightLimitValue) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                errors.ErrorSeverity.ERROR,
                'compareValueFromUltimateExpressionWithAnotherUltimateValue() error, Range error left Limit/hand Value is greater or equal to right limit/hand Value, error while checking if a simple number taken from expression is between range @\$(... \$B(1, 10, ...))');
            return null;
          }
          bool mustBeInt = dartObjectParam2.getField('t3')!.toBoolValue()!;
          bool includesLeftLimitValue =
              dartObjectParam2.getField('t4')!.toBoolValue()!;
          bool includesRightLimitValue =
              dartObjectParam2.getField('t5')!.toBoolValue()!;
          // if null, not a number, may be double type with int value:
          num? number = value.value![ComparableUltimateValue.simple] is num
              ? value.value![ComparableUltimateValue.simple] as num
              : null;

          if (number == null) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                errors.ErrorSeverity.ERROR,
                'compareValueFromUltimateExpressionWithAnotherUltimateValue() error, number is null, error while checking if a simple number taken from expression is between range @\$(... \$B(1, 10, ...))');
            return null;
          }
          bool isIntValue = number == number.roundToDouble() ? true : false;
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              'compareValueFromUltimateExpressionWithAnotherUltimateValue() isBetween = true, leftLimitValue = $leftLimitValue, rightLimitValue = $rightLimitValue, mustBeInt = $mustBeInt, includesLeftLimitValue = $includesLeftLimitValue, includesRightLimitValue = $includesRightLimitValue, isIntValue = $isIntValue, mustBeInt && !isIntValue = ${mustBeInt && !isIntValue} ');
          if (mustBeInt && !isIntValue) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                errors.ErrorSeverity.ERROR,
                'compareValueFromUltimateExpressionWithAnotherUltimateValue() error, \$B() settings require that number taken from expression (simple value) can be of type double but must have int value, error while checking if a simple number taken from expression is between range @\$(... \$B(1, 10, ...))');
            return null;
          }
          return number > leftLimitValue && number < rightLimitValue ||
              includesLeftLimitValue && number == leftLimitValue ||
              includesRightLimitValue && number == rightLimitValue;
        } else if (isRegExp) {
          // final String t1; // source
          // final bool t2; // multiline
          // final bool t3; // case sensitive
          // final bool t4; // unicode
          // final bool t5; // isdotall

          String regexString =
              dartObjectParam2!.getField('t1')!.toStringValue()!;
          bool isMultiline = dartObjectParam2.getField('t2')!.toBoolValue()!;
          bool isCaseSensitive =
              dartObjectParam2.getField('t3')!.toBoolValue()!;
          bool isUnicode = dartObjectParam2.getField('t4')!.toBoolValue()!;
          bool isDotAll = dartObjectParam2.getField('t5')!.toBoolValue()!;
          String? string =
              value.value![ComparableUltimateValue.simple] is String
                  ? value.value![ComparableUltimateValue.simple] as String
                  : null;
          if (string == null) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                errors.ErrorSeverity.ERROR,
                'compareValueFromUltimateExpressionWithAnotherUltimateValue() error, string is null, error while checking if a string taken from expression matches RegExp conditions stipulated in the @\$(... \$R()...) instance');
          }
          RegExp regex = RegExp(regexString,
              multiLine: isMultiline,
              caseSensitive: isCaseSensitive,
              unicode: isUnicode,
              dotAll: isDotAll);
          return regex.hasMatch(string!);
        }
      } else if (value.value?.keys.contains(ComparableUltimateValue.simple) ==
              true &&
          value2.value?.keys.contains(ComparableUltimateValue.simple) == true) {
        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() Comparing two simple values value.value is null ${value.value == null} value2.value is null ${value2.value == null} ,value.value![ComparableUltimateValue.simple] == value2.value![ComparableUltimateValue.simple] it is: ${value.value?[ComparableUltimateValue.simple] == value2.value?[ComparableUltimateValue.simple]}');
        return value.value![ComparableUltimateValue.simple] ==
            value2.value![ComparableUltimateValue.simple];
      } else if (!value2HasInstanceCreationLikeExpressionAny$Param &&
          value.value?.keys.contains(ComparableUltimateValue.dartObject) ==
              true &&
          value2.value?.keys.contains(ComparableUltimateValue.dartObject) ==
              true) {
        return value.value![ComparableUltimateValue.dartObject] ==
            value2.value![ComparableUltimateValue.dartObject];
      } else if (value.value?.keys
                  .contains(ComparableUltimateValue.expression) ==
              true &&
          value2.value?.keys.contains(ComparableUltimateValue.expression) ==
              true) {
        // DartObject docs: Returns a representation of the value of this variable, forcing the value to be computed if it had not previously been computed, or null if either this variable was not declared with the 'const' modifier or if the value of this variable could not be computed because of errors.
        // !!! so computeConstantValue doesn't argument doesn't have to be const but the last assignment of the value must be computable

        Expression? expressionF =
            value.value?[ComparableUltimateValue.expression] as Expression?;
        Expression? expressionF2 =
            value2.value?[ComparableUltimateValue.expression] as Expression?;
        // FIXME: NOT fixme just read this:
        // why is dartObject needed? it is needed only when instance like exression has any $() instance expression as param f.e. @$(abc($(......))) or abc([$(.......), 2])
        // so the dartObjectF2 must not be null when there is the inside/second param $(.......) constructor call.
        DartObject? dartObjectF2;
        try {
          dartObjectF2 =
              dartObjectParam2 ?? // some following conditions are a bit unnecessary
                  (expressionParam2SupportFordartObjectParam2 != null &&
                          value2HasInstanceCreationLikeExpressionAny$Param
                      ? dartObjectParam2
                      : dartObjectParam2SupportForExpression2 ??
                          value2.value?[ComparableUltimateValue.dartObject]
                              as DartObject?) as DartObject;
        } catch (e, stackTrace) {
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              '''compareValueFromUltimateExpressionWithAnotherUltimateValue() catched diagnostic error, it won't be rethrown and no related return call.  - : Couldn\'t have obtained a dartObjectF2 for the second expression param expression2 (by convention rule the param is related annotation constructor @\$(param, param) param inside the annotation),
              expressionParam2SupportFordartObjectParam2 == $expressionParam2SupportFordartObjectParam2,
              value2HasInstanceCreationLikeExpressionAny\$Param = ${value2HasInstanceCreationLikeExpressionAny$Param}
              expressionParam2SupportFordartObjectParam2 != null && value2HasInstanceCreationLikeExpressionAny\$Param == ${expressionParam2SupportFordartObjectParam2 != null && value2HasInstanceCreationLikeExpressionAny$Param}
              dartObjectParam2 == $dartObjectParam2,
              dartObjectParam2SupportForExpression2 == $dartObjectParam2SupportForExpression2,
              value2.value?[ComparableUltimateValue.dartObject] == ${value2.value?[ComparableUltimateValue.dartObject]}
              error messagge = $e, stackTrace = $stackTrace''');
        }

        if (value2HasInstanceCreationLikeExpressionAny$Param &&
            dartObjectF2 == null) {
          // FIXME: DON'T REMEMBER IF WE NEED TO FORCE IT TO BE NOT NULL, BUT THE METHOD WAS MUCH CHANGED TO WORK WITH ACCOMPANYING DARTOBJECT OR EXPRESSION FOR expression2 and dartObject2 method params
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              errors.ErrorSeverity.ERROR,
              '''compareValueFromUltimateExpressionWithAnotherUltimateValue() error: dartObjectF2 == null and there is instance like exression has any \$() instance expression as param f.e. @\$(abc(\$(......))) or abc([\$(.......), 2]) - at this stage we expect it not to be null - see comments around the place in the code. the condition causing this error is value2HasInstanceCreationLikeExpressionAny\$Param&&dartObjectF2 == null and it produces true''');
          return null;
        }

        List<bool?> checkingReturnTypesAndValuesSubCalls = [];

        if (expressionF is InstanceCreationExpression &&
            expressionF2 is InstanceCreationExpression) {
          // Now we could compare parameters of both and know if they are equal.

          // FIXME: Read not perfectly clear desc of .isConst and expressionF.inConstantContext
          // for now based on an assumption simply that .isConst guaratees calling const constructor anyway.
          if ((expressionMustBeConst && !expressionF.isConst) ||
              (expression2MustBeConst2 && !expressionF2.isConst)) {
            // TODO: FIXME:
            // TODO: FIXME:
            // TODO: FIXME:
            // JUST TO DO :) for constructor invokations add special instance $MUTABLE() (or default is mutable and add $CONST() instead) (maybe $STATE) where a constructor invokation (expression or variable) or variable doesn't have to be const internally but one (min and max at the same time) known assignment is required as it already is. Which means a constructor expression declared with the same constructor params that can be changed or not internally.
            // then no const is required and is ignored
            // below:
            // not an error message - just doesn't much requirements
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() error: at least one expression must be const but isn't expressionMustBeConst == ${expressionMustBeConst} expression2MustBeConst2 == ${expression2MustBeConst2}, at least one constructor of constructor invokation is not const constructor. Some const info: expressionF.isConst = ${expressionF.isConst} expressionF2.isConst = ${expressionF2.isConst} expressionF.inConstantContext == ${expressionF.inConstantContext} expressionF.inConstantContext == ${expressionF2.inConstantContext}               
                    expressionF.constructorName.staticElement?.isConst == ${expressionF.constructorName.staticElement?.isConst}    
                    expressionF.constructorName.staticElement?.declaration.isConst = ${expressionF.constructorName.staticElement?.declaration.isConst}
                    expressionF2.constructorName.staticElement?.isConst == ${expressionF2.constructorName.staticElement?.isConst}    
                    expressionF2.constructorName.staticElement?.declaration.isConst = ${expressionF2.constructorName.staticElement?.declaration.isConst}
                    ''');
            return null;
          } else if (expressionF.constructorName.name !=
              expressionF2.constructorName.name) {
            // NOT AN ERROR/SYNTAX ERROR, BUT RETURNS NULL
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() two compared constructor name do not mach: expressionF.constructorName.name == ${expressionF.constructorName.name}, expressionF2.constructorName.name == ${expressionF2.constructorName.name} ');
            return null;
          }

          ConstructorElement? constructorDeclaration =
              expressionF.constructorName.staticElement?.declaration;

          bool isConstConstructor = true;
          //if (expressionF.argumentList.arguments.length != 0) {
          //  constructorDeclaration = expressionF.argumentList.arguments.first
          //      .staticParameterElement?.declaration.enclosingElement;
          //} else if (expressionF2.argumentList.arguments.length != 0) {
          //  constructorDeclaration = expressionF2.argumentList.arguments.first
          //      .staticParameterElement?.declaration.enclosingElement;
          //}
          //if (constructorDeclaration != null) {
          //  if (constructorDeclaration is! ConstructorDeclaration) {
          //    addLintMessage(
          //        reporter,
          //        diagnosticMessageNode ?? expression ?? expression2!,
          //        msgDebugMode
          //            ? errors.ErrorSeverity.ERROR
          //            : errors.ErrorSeverity.INFO,
          //        'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() #G4 ');
          //    constructorDeclaration =
          //        constructorDeclaration.enclosingElement;
          //    if (constructorDeclaration is! ConstructorDeclaration) {
          //      addLintMessage(
          //          reporter,
          //          diagnosticMessageNode ?? expression ?? expression2!,
          //          msgDebugMode
          //              ? errors.ErrorSeverity.ERROR
          //              : errors.ErrorSeverity.INFO,
          //          'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() #G5 ');
          //      constructorDeclaration =
          //          constructorDeclaration?.enclosingElement;
          //    }
          //    if (constructorDeclaration is ConstructorDeclaration) {
          //      addLintMessage(
          //          reporter,
          //          diagnosticMessageNode ?? expression ?? expression2!,
          //          msgDebugMode
          //              ? errors.ErrorSeverity.ERROR
          //              : errors.ErrorSeverity.INFO,
          //          'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() #G6 ');
          //      isConstConstructor =
          //          (constructorDeclaration as ConstructorDeclaration)
          //                  .constKeyword !=
          //              null;
          //    }
          //  }
          //}
          if (!isConstConstructor) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                errors.ErrorSeverity.ERROR,
                'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() Error: isConstConstructor == false');
          }
          List<ParameterElement?>? declarationParameterElements;
          if (constructorDeclaration is ConstructorElement) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() #G7 ');
            declarationParameterElements =
                (constructorDeclaration as ConstructorElement).parameters;
            if (declarationParameterElements == null) {
              // probably a syntax like error should never happen or analyser problem that shouldn't occur
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  errors.ErrorSeverity.ERROR,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() #G8 part InstanceCreationExpression() Error: This is unexpected for the declarationParameterElements to be null not a List<ParameterElement?>');
              return null;
            }
          } else {
            // probably a syntax like error should never happen or analyser problem that shouldn't occur
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                errors.ErrorSeverity.ERROR,
                'compareValueFromUltimateExpressionWithAnotherUltimateValue() #G9 part InstanceCreationExpression() Error: constructorDeclaration is! ConstructorDeclaration');
            return null;
          }

          // declaration

          //({
          //    List<Expression> expressions,
          //    bool wasThereAnyEmptyReturnStatement,
          //    bool wasThereAnyEmptyFunctionBody,
          //  })? getUltimateConstLikeExpressions(
          var thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = false;
          if (declarationParameterElements != null) {
            for (int i = 0; i < declarationParameterElements.length; i++) {
              String name = declarationParameterElements[i]!.name;
              Expression? expressionFCorrespondingParam;
              Expression? expressionF2CorrespondingParam2;
              DartObject? dartObjectF2CorrespondingParam2;
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() #G71 declarationParameterElements[i]!.name = ${declarationParameterElements[i]!.name}, declarationParameterElements[i]!.name = ${declarationParameterElements[i]!.name}, ${declarationParameterElements[i]!.displayName}, ${declarationParameterElements[i]!.getDisplayString()}, ${declarationParameterElements[i]!.declaration.name}, ${declarationParameterElements[i]!.declaration.displayName}, expressionF.argumentList.arguments.length = ${expressionF.argumentList.arguments.length} expressionF2.argumentList.arguments.length = ${expressionF2.argumentList.arguments.length}');

              for (int k = 0;
                  k < expressionF.argumentList.arguments.length;
                  k++) {
                if (name ==
                    expressionF.argumentList.arguments[k].staticParameterElement
                        ?.name) {
                  //addLintMessage(
                  //    reporter,
                  //    diagnosticMessageNode ?? expression ?? expression2!,
                  //    msgDebugMode
                  //        ? errors.ErrorSeverity.ERROR
                  //        : errors.ErrorSeverity.INFO,
                  //    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() #G72 expressionF.argumentList.arguments[k].staticParameterElement?.declaration.name = ${expressionF.argumentList.arguments[k].staticParameterElement?.declaration.name} expressionF.argumentList.arguments[k].staticParameterElement?.name = ${expressionF.argumentList.arguments[k].staticParameterElement?.name} expressionF.argumentList.arguments[k].unParenthesized = ${expressionF.argumentList.arguments[k].unParenthesized}, expressionF.argumentList.arguments[k] = ${expressionF.argumentList.arguments[k]}');
                  expressionFCorrespondingParam =
                      expressionF.argumentList.arguments[k].unParenthesized;
                }
              }
              for (int k = 0;
                  k < expressionF2.argumentList.arguments.length;
                  k++) {
                //addLintMessage(
                //    reporter,
                //    diagnosticMessageNode ?? expression ?? expression2!,
                //    msgDebugMode
                //        ? errors.ErrorSeverity.ERROR
                //        : errors.ErrorSeverity.INFO,
                //    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() #G73 expressionF2.argumentList.arguments[k].staticParameterElement?.declaration.name = ${expressionF2.argumentList.arguments[k].staticParameterElement?.declaration.name} expressionF2.argumentList.arguments[k].staticParameterElement?.name = ${expressionF2.argumentList.arguments[k].staticParameterElement?.name} expressionF2.argumentList.arguments[k].unParenthesized = ${expressionF2.argumentList.arguments[k].unParenthesized}, expressionF2.argumentList.arguments[k] = ${expressionF2.argumentList.arguments[k]}');
                if (name ==
                    expressionF2.argumentList.arguments[k]
                        .staticParameterElement?.name) {
                  expressionF2CorrespondingParam2 =
                      getUltimateNonIdentifierExpression(
                    reporter,
                    returnStatements,
                    assignmentExpressionsByElementId,
                    variableDeclarationsByElementId,
                    expressionF2.argumentList.arguments[k].unParenthesized,
                    expression2,
                    diagnosticMessageNode,
                  );
                }
              }

              if (expressionFCorrespondingParam == null &&
                  expressionF2CorrespondingParam2 == null) {
                continue;
              } else if (expressionFCorrespondingParam != null &&
                      expressionF2CorrespondingParam2 == null ||
                  expressionFCorrespondingParam == null &&
                      expressionF2CorrespondingParam2 != null) {
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() info returning false: at least one expression to be compared was null but the other not null, so the top level values are not equal. expressionFCorrespondingParam = ${expressionFCorrespondingParam}, expressionF2CorrespondingParam2 = $expressionF2CorrespondingParam2');
                return false;
              }

              // FIXME: For the DartObject when it is a class instance (much easier with List, Map, Set, Record)
              // we don't have acces to constructor argument list so
              // we need to require that if there is any given argument to the constructor:
              // it must be initialized in the paranthesis (...) not anywhere after abc(): not here {constructor body}
              // the constructor param must have a corresponding property with the same name and take value directly from the constructor.
              // cannot have default value.
              // NOTE! Because in the past i couldn't reliably have taken from DartObject proper corresponding expression (in this case instance creation object with params)
              // then i don't have to try to get one.
              // The FIXME: is that i must implement it but it can be done later - before that anybody need to remember when using it during the development mode.
              if (dartObjectF2 != null) {
                dartObjectF2CorrespondingParam2 = dartObjectF2.getField(name);
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() second \$() #1 dartObjectF2CorrespondingParam2 = $dartObjectF2CorrespondingParam2');
              }

              //  var value1111 = getUltimateNonIdentifierExpression(
              //    reporter,
              //    returnStatements,
              //    assignmentExpressionsByElementId,
              //    variableDeclarationsByElementId,
              //    arguments[k] as Expression,
              //    null,
              //    diagnosticMessageNode
              //  );

              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() second \$() #1.15 
                        dartObjectF2CorrespondingParam2 = $dartObjectF2CorrespondingParam2, 
                        expressionF2CorrespondingParam2 is InstanceCreationExpression == ${expressionF2CorrespondingParam2 is InstanceCreationExpression}, 
                        is \$() instance: ${expressionF2CorrespondingParam2 != null && expressionF2CorrespondingParam2.staticType != null && (expressionF2CorrespondingParam2.staticType?.getDisplayString() == '\$' || expressionF2CorrespondingParam2.staticType?.getDisplayString().indexOf('\$<') == 0)}
                  ''');

              if (expressionF2CorrespondingParam2
                      is InstanceCreationExpression &&
                  expressionF2CorrespondingParam2.staticType != null &&
                  (expressionF2CorrespondingParam2.staticType
                              ?.getDisplayString() ==
                          '\$' ||
                      expressionF2CorrespondingParam2.staticType
                              ?.getDisplayString()
                              .indexOf('\$<') ==
                          0)) {
                if (dartObjectF2CorrespondingParam2 == null) {
                  // for now it is considered syntax error because field of name (variable/pointer name here) must be initialized like this abc(this.name) with no default value -
                  // - problem exists only for constructors not list/Map/Set/Record literals
                  // and because dartObjectF2.getField(name) is missing a class inspected now wasn't properly constructed.
                  addLintMessage(
                      reporter,
                      diagnosticMessageNode ?? expression ?? expression2!,
                      errors.ErrorSeverity.ERROR,
                      'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() Error: dartObjectF2CorrespondingParam2==null and at this stage it must be DartObject See FIXME: / todo info comments when the producing of this message occurs in the code.                   // for now it is considered syntax error because field of name (variable/pointer name here) must be initialized like this abc(this.name) with no default value - only for constructors not list literals // and because dartObjectF2.getField(name) is missing a class inspected now wasn\'t properly constructed.');
                  return null;
                }
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() second \$() #2 ');
                Expando<Identifier> topLevelIdentifiersProducingExpressions =
                    Expando<Identifier>();
                var expressionFCorrespondingParamSubExpressions =
                    // it is not used anywhere - conditions - return fields of records  bool wasThereAnyEmptyFunctionBody, bool wasThereAnyEmptyReturnStatement}
                    getUltimateNonConditionalNorSwitchExpressions(
                        reporter,
                        returnStatements,
                        variableDeclarationsByElementId,
                        assignmentExpressionsByElementId,
                        expressionFCorrespondingParam!,
                        topLevelIdentifiersProducingExpressions);
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() second \$() #2.1 expressionFCorrespondingParamSubExpressions.expressions = ${expressionFCorrespondingParamSubExpressions.expressions}, to be called with dartObjectF2CorrespondingParam2 = $dartObjectF2CorrespondingParam2, expressionF2CorrespondingParam2 = $expressionF2CorrespondingParam2, topLevelIdentifiersProducingExpressions = $topLevelIdentifiersProducingExpressions');

                thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = true;

                checkingReturnTypesAndValuesSubCalls
                    .add(checkingReturnTypesAndValues(
                        reporter,
                        returnStatements,
                        assignmentExpressionsByElementId,
                        variableDeclarationsByElementId,
                        methodDeclaration,
                        expressionFCorrespondingParamSubExpressions.expressions,
                        topLevelIdentifiersProducingExpressions,
                        // for nested calls:
                        dartObjectF2CorrespondingParam2,
                        expressionF2CorrespondingParam2));
              } else {
                bool? comparisonResult =
                    compareValueFromUltimateExpressionWithAnotherUltimateValue(
                        reporter,
                        returnStatements,
                        assignmentExpressionsByElementId,
                        variableDeclarationsByElementId,
                        expression: expressionFCorrespondingParam,
                        expressionMustBeConst: expressionMustBeConst,
                        expression2: expressionF2CorrespondingParam2,
                        dartObjectParam2SupportForExpression2:
                            dartObjectF2CorrespondingParam2,
                        diagnosticMessageNode:
                            diagnosticMessageNode ?? expression ?? expression2!,
                        expression2MustBeConst2: expression2MustBeConst2,
                        methodDeclaration: methodDeclaration);

                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() comparisonResult = $comparisonResult of expressionFCorrespondingParam = $expressionFCorrespondingParam, expressionF2CorrespondingParam2 = $expressionF2CorrespondingParam2  ');

                if (comparisonResult == null || comparisonResult == false) {
                  addLintMessage(
                      reporter,
                      diagnosticMessageNode ?? expression ?? expression2!,
                      msgDebugMode
                          ? errors.ErrorSeverity.ERROR
                          : errors.ErrorSeverity.INFO,
                      'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() info: comparisonResult = ${comparisonResult} comparisonResult == null||comparisonResult==false Two expression compared: expression = ${expression}, expression2 = ${expression2}');
                  return comparisonResult;
                }
              }
            }
          }
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              'compareValueFromUltimateExpressionWithAnotherUltimateValue() part InstanceCreationExpression() success, thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = ${thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues}, checkingReturnTypesAndValuesSubCalls = ${checkingReturnTypesAndValuesSubCalls}, if thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues == true then this success is not full because for one or more expression InstanceCreationInvokation constructor invokation param there was another \$() instance which required a nested checkingReturnTypesAndValues which mail detect type/value error or succeed, some data: return true comparisonResult == null||comparisonResult==false Two expression compared: expression = ${expression}, expression2 = ${expression2}');
          return checkingReturnTypesAndValuesSubCalls.contains(false)
              ? false
              : checkingReturnTypesAndValuesSubCalls.contains(null)
                  ? null
                  : true;
        } else if (expressionF is SetOrMapLiteral &&
            expressionF2 is SetOrMapLiteral) {
          if ((expressionMustBeConst && !expressionF.isConst) ||
              (expression2MustBeConst2 && !expressionF2.isConst)) {
            // TODO: FIXME:
            // TODO: FIXME:
            // TODO: FIXME:
            // JUST TO DO :) for constructor invokations add special instance $MUTABLE() (or default is mutable and add $CONST() instead) (maybe $STATE) where a constructor invokation (expression or variable) or variable doesn't have to be const internally but one (min and max at the same time) known assignment is required as it already is. Which means a constructor expression declared with the same constructor params that can be changed or not internally.
            // then no const is required and is ignored
            // below
            // not an error - just it doesn't match the requirements
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() expressionMustBeConst == ${expressionMustBeConst} expression2MustBeConst2 == ${expression2MustBeConst2} at least one SetOrMapLiteral expression is not const. Some const info: expressionF.isConst = ${expressionF.isConst} expressionF2.isConst = ${expressionF2.isConst} expressionF.inConstantContext == ${expressionF.inConstantContext} expressionF.inConstantContext == ${expressionF2.inConstantContext}''');
            return null;
          }

          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() at least one SetOrMapLiteral expression is not const. Some const info: expressionF.isConst = ${expressionF.isConst} expressionF2.isConst = ${expressionF2.isConst} expressionF.inConstantContext == ${expressionF.inConstantContext} expressionF.inConstantContext == ${expressionF2.inConstantContext}''');
          if (expressionF.isMap != expressionF2.isMap) {
            // not an error or syntax error
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() one of the elmeents is Map but the other is Set expressionF.isMap == ${expressionF.isMap}, expressionF2.isMap == ${expressionF2.isMap}''');
            return null;
          }
          if (expressionF.elements.length != expressionF2.elements.length) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() the number of elements in each list is not equal so the two ListLiterals (a class representing a least) are not equal: expressionF.elements.length == ${expressionF.elements.length} expressionF2.elements.length == ${expressionF2.elements.length}''');
            return false;
          }
          Map<DartObject?, DartObject?>? map;
          Set<DartObject?>? set;

          if (expressionF2.isMap) {
            map = dartObjectF2?.toMapValue();
            if (value2HasInstanceCreationLikeExpressionAny$Param &&
                map == null) {
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  errors.ErrorSeverity.ERROR,
                  '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() error toMapValue() produced null - it must be a proper Map instance''');
              return null;
            }
          } else {
            set = dartObjectF2?.toSetValue();
            if (value2HasInstanceCreationLikeExpressionAny$Param &&
                set == null) {
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  errors.ErrorSeverity.ERROR,
                  '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() error toSetValue() produced null - it must be a proper Set instance''');
              return null;
            }
          }

          var thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = false;
          for (int i = 0; i < expressionF.elements.length; i++) {
            if ((expressionF.elements[i] is! Expression &&
                    expressionF.elements[i] is! MapLiteralEntry) ||
                (expressionF2.elements[i] is! Expression &&
                    expressionF2.elements[i] is! MapLiteralEntry)) {
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  errors.ErrorSeverity.ERROR,
                  '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() error: i == $i one of i element is not an of Expression nor MapLiteralEntry instance as required expressionF.elements[i] is! Expression == ${expressionF.elements[i] is! Expression}, expressionF.elements[i] is! MapLiteralEntry == ${expressionF.elements[i] is! MapLiteralEntry}, expressionF2.elements[i] is! Expression == ${expressionF2.elements[i] is! Expression}, expressionF2.elements[i] is! MapLiteralEntry == ${expressionF2.elements[i] is! MapLiteralEntry}''');
              return null;
            }

            Expression expressionValue = expressionF.isSet
                ? expressionF.elements[i] as Expression
                : (expressionF.elements[i] as MapLiteralEntry).value;

            Expression expression2Value = expressionF2.isSet
                ? expressionF2.elements[i] as Expression
                : (expressionF2.elements[i] as MapLiteralEntry).value;

            expression2Value = expression2Value is Identifier
                ? getUltimateNonIdentifierExpression(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      expression2Value,
                      expression2,
                      diagnosticMessageNode,
                    ) ??
                    expression2Value
                : expression2Value;

            DartObject dartObject2Value = expressionF2.isSet
                ? set?.elementAt(i) as DartObject
                : map?.entries.elementAt(i).value as DartObject;

            Expression? expressionKey = expressionF.isSet
                ? null
                : (expressionF.elements[i] as MapLiteralEntry).key;

            Expression? expression2Key = expressionF2.isSet
                ? null
                : (expressionF2.elements[i] as MapLiteralEntry).key;

            expression2Key = expression2Key is Identifier
                ? getUltimateNonIdentifierExpression(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      expression2Key,
                      expression2,
                      diagnosticMessageNode,
                    ) ??
                    expression2Key
                : expression2Key;

            DartObject? dartObject2Key = expressionF2.isSet
                ? null
                : map?.entries.elementAt(i).key as DartObject;

            bool comparison1WasUsed = true;
            bool comparison2WasUsed = true;
            bool? comparisonResult;
            if (expression2Value is InstanceCreationExpression &&
                expression2Value.staticType != null &&
                (expression2Value.staticType?.getDisplayString() == '\$' ||
                    expression2Value.staticType
                            ?.getDisplayString()
                            .indexOf('\$<') ==
                        0)) {
              /// INFO: the conditions just here also handle the key for a Map
              /// so no need to repeat addLintMessage error for the key much below, here it will return null, the code below won'nt be reached
              if (expressionF2.isSet && set?.elementAt(i) == null) {
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    errors.ErrorSeverity.ERROR,
                    '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() error: i == $i set!.elementAt(i) == null (is not a required DartObject instance) expressionF2.elements[i] == ${expressionF2.elements[i]}, full expressionF2 == $expressionF2''');
                return null;
              } else if (expressionF2.isMap &&
                  (map?.entries.elementAt(i) == null ||
                      map?.entries.elementAt(i).key == null ||
                      map?.entries.elementAt(i).value == null)) {
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    errors.ErrorSeverity.ERROR,
                    '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() error: i == $i at least one of the following three things is not a DartObject instance but null (none can be null): map!.entries.elementAt(i) == ${map!.entries.elementAt(i)}, map!.entries.elementAt(i).key == ${map!.entries.elementAt(i).key}, map!.entries.elementAt(i).value == ${map!.entries.elementAt(i).value},  expressionF2.elements[i] == ${expressionF2.elements[i]}, full expressionF2 == $expressionF2  ''');
                return null;
              }

              comparison1WasUsed = false;
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() second \$() #2 ');

              Expando<Identifier> topLevelIdentifiersProducingExpressions =
                  Expando<Identifier>();
              var expressionFCorrespondingParamSubExpressions =
                  // it is not used anywhere - conditions - return fields of records  bool wasThereAnyEmptyFunctionBody, bool wasThereAnyEmptyReturnStatement}
                  getUltimateNonConditionalNorSwitchExpressions(
                      reporter,
                      returnStatements,
                      variableDeclarationsByElementId,
                      assignmentExpressionsByElementId,
                      expressionValue,
                      topLevelIdentifiersProducingExpressions);
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() second \$() #2.1 expressionFCorrespondingParamSubExpressions.expressions = ${expressionFCorrespondingParamSubExpressions.expressions}, to be called with dartObject2Value = $dartObject2Value, expression2Value = $expression2Value, topLevelIdentifiersProducingExpressions = $topLevelIdentifiersProducingExpressions');

              thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = true;

              checkingReturnTypesAndValuesSubCalls
                  .add(checkingReturnTypesAndValues(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      methodDeclaration,
                      expressionFCorrespondingParamSubExpressions.expressions,
                      topLevelIdentifiersProducingExpressions,
                      // for nested calls:
                      dartObject2Value,
                      expression2Value));
            } else {
              comparisonResult =
                  compareValueFromUltimateExpressionWithAnotherUltimateValue(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      expression: expressionValue,
                      expressionMustBeConst: expressionMustBeConst,
                      expression2: expression2Value,
                      dartObjectParam2SupportForExpression2: dartObject2Value,
                      diagnosticMessageNode:
                          diagnosticMessageNode ?? expression ?? expression2!,
                      expression2MustBeConst2: expression2MustBeConst2,
                      methodDeclaration: methodDeclaration);
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLitreal() comparisonResult (for value part) = $comparisonResult of ');
            }

            bool? comparisonResult2;
            if (expressionF.isMap) {
              if (expression2Key is InstanceCreationExpression &&
                  expression2Key.staticType != null &&
                  (expression2Key.staticType?.getDisplayString() == '\$' ||
                      expression2Key.staticType
                              ?.getDisplayString()
                              .indexOf('\$<') ==
                          0)) {
                // READ THIS, READ THIS - at this stage dartObject2Key must be DartObject,
                // but no need to check it here, it is done for dartObject2Value with taking key also into account.

                comparison2WasUsed = false;
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() second \$() #2 ');

                Expando<Identifier> topLevelIdentifiersProducingExpressions =
                    Expando<Identifier>();
                var expressionFCorrespondingParamSubExpressions =
                    // it is not used anywhere - conditions - return fields of records  bool wasThereAnyEmptyFunctionBody, bool wasThereAnyEmptyReturnStatement}
                    getUltimateNonConditionalNorSwitchExpressions(
                        reporter,
                        returnStatements,
                        variableDeclarationsByElementId,
                        assignmentExpressionsByElementId,
                        expressionKey!,
                        topLevelIdentifiersProducingExpressions);
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() second \$() #2.1 expressionFCorrespondingParamSubExpressions.expressions = ${expressionFCorrespondingParamSubExpressions.expressions}, to be called with dartObject2Key = $dartObject2Key, expression2Key = $expression2Key, topLevelIdentifiersProducingExpressions = $topLevelIdentifiersProducingExpressions');

                thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = true;

                checkingReturnTypesAndValuesSubCalls
                    .add(checkingReturnTypesAndValues(
                        reporter,
                        returnStatements,
                        assignmentExpressionsByElementId,
                        variableDeclarationsByElementId,
                        methodDeclaration,
                        expressionFCorrespondingParamSubExpressions.expressions,
                        topLevelIdentifiersProducingExpressions,
                        // for nested calls:
                        dartObject2Key,
                        expression2Key));
              } else {
                comparisonResult2 =
                    compareValueFromUltimateExpressionWithAnotherUltimateValue(
                        reporter,
                        returnStatements,
                        assignmentExpressionsByElementId,
                        variableDeclarationsByElementId,
                        expression: expressionKey,
                        expressionMustBeConst: expressionMustBeConst,
                        expression2: expression2Key,
                        dartObjectParam2SupportForExpression2: dartObject2Key,
                        diagnosticMessageNode:
                            diagnosticMessageNode ?? expression ?? expression2!,
                        expression2MustBeConst2: expression2MustBeConst2,
                        methodDeclaration: methodDeclaration);

                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() comparisonResult2 (for key part) = $comparisonResult2 ');
              }
            }

            if ((comparison1WasUsed &&
                    (comparisonResult == null || comparisonResult == false)) ||
                (comparison2WasUsed &&
                    expressionF.isMap &&
                    (comparisonResult2 == null ||
                        comparisonResult2 == false))) {
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() info: comparison1WasUsed (value of map) = $comparison1WasUsed, comparison2WasUsed (key of map) == $comparison2WasUsed, comparisonResult = ${comparisonResult} comparisonResult == null||comparisonResult==false Two highest level expressions (compareValueFromUltimateExpressionWithAnotherUltimateValue() params) compared: expression = ${expression}, expression2 = ${expression2}');
              return comparisonResult == null || comparisonResult2 == null
                  ? null
                  : false;
            }
          }
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              'compareValueFromUltimateExpressionWithAnotherUltimateValue() part SetOrMapLiteral() success, thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = ${thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues}, checkingReturnTypesAndValuesSubCalls = ${checkingReturnTypesAndValuesSubCalls}, if thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues == true then this success is not full because for one or more expression InstanceCreationInvokation constructor invokation param there was another \$() instance which required a nested checkingReturnTypesAndValues which mail detect type/value error or succeed, some data: return true comparisonResult == null||comparisonResult==false Two expression compared: expression = ${expression}, expression2 = ${expression2}');
          return checkingReturnTypesAndValuesSubCalls.contains(false)
              ? false
              : checkingReturnTypesAndValuesSubCalls.contains(null)
                  ? null
                  : true;
        } else if (expressionF is ListLiteral && expressionF2 is ListLiteral) {
          if ((expressionMustBeConst && !expressionF.isConst) ||
              (expression2MustBeConst2 && !expressionF2.isConst)) {
            // TODO: FIXME:
            // TODO: FIXME:
            // TODO: FIXME:
            // JUST TO DO :) for constructor invokations add special instance $MUTABLE() (or default is mutable and add $CONST() instead) (maybe $STATE) where a constructor invokation (expression or variable) or variable doesn't have to be const internally but one (min and max at the same time) known assignment is required as it already is. Which means a constructor expression declared with the same constructor params that can be changed or not internally.
            // then no const is required and is ignored
            // below:
            // not an error - just it doesn't match the requirements
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() expressionMustBeConst == ${expressionMustBeConst} expression2MustBeConst2 == ${expression2MustBeConst2} at least one ListLiteral expression is not const. Some const info: expressionF.isConst = ${expressionF.isConst} expressionF2.isConst = ${expressionF2.isConst} expressionF.inConstantContext == ${expressionF.inConstantContext} expressionF.inConstantContext == ${expressionF2.inConstantContext}''');
            return null;
          }

          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() Some const info: expressionMustBeConst == ${expressionMustBeConst} expression2MustBeConst2 == ${expression2MustBeConst2} expressionF.isConst = ${expressionF.isConst} expressionF2.isConst = ${expressionF2.isConst} expressionF.inConstantContext == ${expressionF.inConstantContext} expressionF.inConstantContext == ${expressionF2.inConstantContext}''');
          if (expressionF.elements.length != expressionF2.elements.length) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() the number of elements in each list is not equal so the two ListLiterals (a class representing a least) are not equal: expressionF.elements.length == ${expressionF.elements.length} expressionF2.elements.length == ${expressionF2.elements.length}''');
            return false;
          }

          List<DartObject?>? list = dartObjectF2!.toListValue();

          if (value2HasInstanceCreationLikeExpressionAny$Param &&
              list == null) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                errors.ErrorSeverity.ERROR,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() error toListValue() produced null - it must be a proper List instance''');
            return null;
          }

          var thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = false;
          for (int i = 0; i < expressionF.elements.length; i++) {
            if (expressionF.elements[i] is! Expression ||
                expressionF2.elements[i] is! Expression) {
              // later edit: can't imagine this could happen
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  errors.ErrorSeverity.ERROR,
                  '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() error: i == $i at least one of CollectionElement instance is not an Expression instance expressionF.elements[i] is Expression == ${expressionF.elements[i] is Expression} expressionF2.elements[i] is Expression == ${expressionF2.elements[i] is Expression}''');
              return null;
            }

            Expression expressionValue = expressionF.elements[i] as Expression;
            Expression expression2Value =
                expressionF2.elements[i] as Expression;
            expression2Value = expression2Value is Identifier
                ? getUltimateNonIdentifierExpression(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      expression2Value,
                      expression2,
                      diagnosticMessageNode,
                    ) ??
                    expression2Value
                : expression2Value;
            DartObject? dartObject2Value = list?[i];

            if (expression2Value is InstanceCreationExpression &&
                expression2Value.staticType != null &&
                (expression2Value.staticType?.getDisplayString() == '\$' ||
                    expression2Value.staticType
                            ?.getDisplayString()
                            .indexOf('\$<') ==
                        0)) {
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() second \$() #2 ');
              if (list?[i] == null) {
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    errors.ErrorSeverity.ERROR,
                    '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() error: i == $i list.elementAt(i) == null (is not a required DartObject instance) expressionF2.elements[i] == ${expressionF2.elements[i]}, full expressionF2 == $expressionF2''');
                return null;
              }
              Expando<Identifier> topLevelIdentifiersProducingExpressions =
                  Expando<Identifier>();
              var expressionFCorrespondingParamSubExpressions =
                  // it is not used anywhere - conditions - return fields of records  bool wasThereAnyEmptyFunctionBody, bool wasThereAnyEmptyReturnStatement}
                  getUltimateNonConditionalNorSwitchExpressions(
                      reporter,
                      returnStatements,
                      variableDeclarationsByElementId,
                      assignmentExpressionsByElementId,
                      expressionValue,
                      topLevelIdentifiersProducingExpressions);
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() second \$() #2.1 expressionFCorrespondingParamSubExpressions.expressions = ${expressionFCorrespondingParamSubExpressions.expressions}, to be called with dartObject2Value = $dartObject2Value, expression2Value = $expression2Value, topLevelIdentifiersProducingExpressions = $topLevelIdentifiersProducingExpressions');

              thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = true;

              checkingReturnTypesAndValuesSubCalls
                  .add(checkingReturnTypesAndValues(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      methodDeclaration,
                      expressionFCorrespondingParamSubExpressions.expressions,
                      topLevelIdentifiersProducingExpressions,
                      // for nested calls:
                      dartObject2Value,
                      expression2Value));
            } else {
              bool? comparisonResult =
                  compareValueFromUltimateExpressionWithAnotherUltimateValue(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      expression: expressionValue,
                      expressionMustBeConst: expressionMustBeConst,
                      expression2: expression2Value,
                      dartObjectParam2SupportForExpression2: dartObject2Value,
                      diagnosticMessageNode:
                          diagnosticMessageNode ?? expression ?? expression2!,
                      expression2MustBeConst2: expression2MustBeConst2,
                      methodDeclaration: methodDeclaration);

              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() comparisonResult = $comparisonResult');

              if (comparisonResult == null || comparisonResult == false) {
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() info: comparisonResult = ${comparisonResult} comparisonResult == null||comparisonResult==false Two expression compared: expression = ${expression}, expression2 = ${expression2}');
                return comparisonResult;
              }
            }
          }
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              'compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() success, thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = ${thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues}, checkingReturnTypesAndValuesSubCalls = ${checkingReturnTypesAndValuesSubCalls}, if thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues == true then this success is not full because for one or more expression InstanceCreationInvokation constructor invokation param there was another \$() instance which required a nested checkingReturnTypesAndValues which mail detect type/value error or succeed, some data: return true comparisonResult == null||comparisonResult==false Two expression compared: expression = ${expression}, expression2 = ${expression2}');
          return checkingReturnTypesAndValuesSubCalls.contains(false)
              ? false
              : checkingReturnTypesAndValuesSubCalls.contains(null)
                  ? null
                  : true;
        } else if (expressionF is RecordLiteral &&
            expressionF2 is RecordLiteral) {
          // 1. RecordType (not literal Expreesion) has namedFields and Positional fields so you need to compare type of each in the == "Type" part
          // not difficult to implement.
          // 2. But here RecordLiteral has fields - list of expressions like list or set
          // Supposedly for enum you don't need to do anything as i can see there is no something special for enum (there is but seems not immediately needed but useful elsewhere)
          // then you will use InstanceCreationExpression and just type comparison enum abc {...} use abc in $(abc, abc.cde) .cde means constructor call InstanceCreationExpression

          if ((expressionMustBeConst && !expressionF.isConst) ||
              (expression2MustBeConst2 && !expressionF2.isConst)) {
            // TODO: FIXME:
            // TODO: FIXME:
            // TODO: FIXME:
            // JUST TO DO :) for constructor invokations add special instance $MUTABLE() (or default is mutable and add $CONST() instead) (maybe $STATE) where a constructor invokation (expression or variable) or variable doesn't have to be const internally but one (min and max at the same time) known assignment is required as it already is. Which means a constructor expression declared with the same constructor params that can be changed or not internally.
            // then no const is required and is ignored
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() expressionMustBeConst == ${expressionMustBeConst} expression2MustBeConst2 == ${expression2MustBeConst2} at least one RecordLiteral expression is not const. Some const info: expressionF.isConst = ${expressionF.isConst} expressionF2.isConst = ${expressionF2.isConst} expressionF.inConstantContext == ${expressionF.inConstantContext} expressionF.inConstantContext == ${expressionF2.inConstantContext}''');
            return null;
          }

          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() at least one RecordLiteral expression is not const. Some const info: expressionF.isConst = ${expressionF.isConst} expressionF2.isConst = ${expressionF2.isConst} expressionF.inConstantContext == ${expressionF.inConstantContext} expressionF.inConstantContext == ${expressionF2.inConstantContext}''');
          if (expressionF.fields.length != expressionF2.fields.length) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() the number of elements in each list is not equal so the two ListLiterals (a class representing a least) are not equal: expressionF.elements.length == ${expressionF.fields.length} expressionF2.elements.length == ${expressionF2.fields.length}''');
            return false;
          }

          // type example, all done different way causes errors.
          // first go positional $1, $2, then named, so then we have pattern/order of doing things for the loop below:
          // (int? x, int y, {int? z}) point = (1, 2, z: 3);

          // Oh, a bit suprised. Temporarily a solution is to have not only a dartObject carrying the Record value but also a corresponding Expression instance - precisely a RecordLiteral with a List of fields. We iterate through the fields and if field[i] is NamedExpression instance - you have a name of the expression and the expression itself. If we need a DartObject instance we do dartObject.getField((expressionF.fields[i] as NamedExpression).name.label.name), but if it is a "normal" Expression we do dartObject.getField('${i+1}')
          var thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = false;
          for (int i = 0; i < expressionF.fields.length; i++) {
            addLintMessage(
                reporter,
                diagnosticMessageNode ?? expression ?? expression2!,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() what we have for i = $i, 
                expressionF.fields[i].runtimeType == ${expressionF.fields[i].runtimeType}, expressionF.fields[i].staticType == ${expressionF.fields[i].staticType},  expressionF.fields[i].staticType?.element == ${expressionF.fields[i].staticType?.element}, expressionF.fields[i].staticType?.element.runtimeType == ${expressionF.fields[i].staticType?.element.runtimeType} expressionF.fields[i].staticType?.element?.id = ${expressionF.fields[i].staticType?.element?.id}, 
                expressionF.fields[i] is NamedExpression = ${expressionF.fields[i] is NamedExpression}, 
                name to be used: ${expressionF.fields[i] is NamedExpression ? (expressionF.fields[i] as NamedExpression).name.label.name : '\$${i + 1}'}
                (dartObjectF2 == null : ${dartObjectF2 == null}) value of field for the mentioned name: ${expressionF.fields[i] is NamedExpression ? dartObjectF2?.getField((expressionF.fields[i] as NamedExpression).name.label.name) : dartObjectF2?.getField('\$${i + 1}')}
                ''');
            if (expressionF.fields[i] is! Expression ||
                expressionF2.fields[i] is! Expression) {
              // Later edit: Can't imagine a situation this could happen
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() Later edit: Can't imagine a situation this could happen at leasst one of CollectionElement instance is not an Expression instance expressionF.elements[i] is Expression == ${expressionF.fields[i] is Expression} expressionF2.elements[i] is Expression == ${expressionF2.fields[i] is Expression}''');
              return null;
            }

            Expression expressionValue =
                expressionF.fields[i] is NamedExpression
                    ? (expressionF.fields[i] as NamedExpression).expression
                    : expressionF.fields[i];
            Expression expression2Value =
                expressionF2.fields[i] is NamedExpression
                    ? (expressionF2.fields[i] as NamedExpression).expression
                    : expressionF2.fields[i];

            expression2Value = expression2Value is Identifier
                ? getUltimateNonIdentifierExpression(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      expression2Value,
                      expression2,
                      diagnosticMessageNode,
                    ) ??
                    expression2Value
                : expression2Value;

            DartObject? dartObject2Value = expressionF.fields[i]
                    is NamedExpression
                ? dartObjectF2?.getField(
                    (expressionF.fields[i] as NamedExpression).name.label.name)
                : dartObjectF2?.getField('\$${i + 1}');

            /*
                expressionF.fields[i].runtimeType == NamedExpressionImpl, expressionF.fields[i].staticType == (int, int),  expressionF.fields[i].staticType?.element == null, expressionF.fields[i].staticType?.element.runtimeType == Null expressionF.fields[i].staticType?.element?.id = null, 
                                expressionF.fields[i] is NamedExpression = true, 
                                name to be used: b
                                (dartObjectF2 == null : true) value of field for the mentioned name: null
                                dart(anno_types_warning)
                annotypes compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() dartObject2Value==null it is expected to be DartObject instance.
            */

            /*else if (dartObjectF2.getField() == null) {
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  errors.ErrorSeverity.ERROR,
                  '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part ListLiteral() error: i == $i list.elementAt(i) == null (is not a required DartObject instance) expressionF2.elements[i] == ${expressionF2.elements[i]}, full expressionF2 == $expressionF2''');
              return null;
            }*/
            if (expression2Value is InstanceCreationExpression &&
                expression2Value.staticType != null &&
                (expression2Value.staticType?.getDisplayString() == '\$' ||
                    expression2Value.staticType
                            ?.getDisplayString()
                            .indexOf('\$<') ==
                        0)) {
              if (dartObject2Value == null) {
                // Later edit: Can't imagine a situation this could happen
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    '''compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() dartObject2Value==null it is expected to be DartObject instance.''');
                return null;
              }
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() second \$() #2 ');

              Expando<Identifier> topLevelIdentifiersProducingExpressions =
                  Expando<Identifier>();
              var expressionFCorrespondingParamSubExpressions =
                  // it is not used anywhere - conditions - return fields of records  bool wasThereAnyEmptyFunctionBody, bool wasThereAnyEmptyReturnStatement}
                  getUltimateNonConditionalNorSwitchExpressions(
                      reporter,
                      returnStatements,
                      variableDeclarationsByElementId,
                      assignmentExpressionsByElementId,
                      expressionValue,
                      topLevelIdentifiersProducingExpressions);
              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() second \$() #2.1 expressionFCorrespondingParamSubExpressions.expressions = ${expressionFCorrespondingParamSubExpressions.expressions}, to be called with dartObject2Value = $dartObject2Value, expression2Value = $expression2Value, topLevelIdentifiersProducingExpressions = $topLevelIdentifiersProducingExpressions');

              thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = true;

              checkingReturnTypesAndValuesSubCalls
                  .add(checkingReturnTypesAndValues(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      methodDeclaration,
                      expressionFCorrespondingParamSubExpressions.expressions,
                      topLevelIdentifiersProducingExpressions,
                      // for nested calls:
                      dartObject2Value,
                      expression2Value));
            } else {
              bool? comparisonResult =
                  compareValueFromUltimateExpressionWithAnotherUltimateValue(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      expression: expressionValue,
                      expressionMustBeConst: expressionMustBeConst,
                      expression2: expression2Value,
                      dartObjectParam2SupportForExpression2: dartObject2Value,
                      diagnosticMessageNode:
                          diagnosticMessageNode ?? expression ?? expression2!,
                      expression2MustBeConst2: expression2MustBeConst2,
                      methodDeclaration: methodDeclaration);

              addLintMessage(
                  reporter,
                  diagnosticMessageNode ?? expression ?? expression2!,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() comparisonResult = $comparisonResult of ');

              if (comparisonResult == null || comparisonResult == false) {
                addLintMessage(
                    reporter,
                    diagnosticMessageNode ?? expression ?? expression2!,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() Error: comparisonResult = ${comparisonResult} comparisonResult == null||comparisonResult==false Two expression compared: expression = ${expression}, expression2 = ${expression2}');
                return comparisonResult;
              }
            }
          }
          addLintMessage(
              reporter,
              diagnosticMessageNode ?? expression ?? expression2!,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              'compareValueFromUltimateExpressionWithAnotherUltimateValue() part RecordLiteral() success, thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues = ${thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues}, checkingReturnTypesAndValuesSubCalls = ${checkingReturnTypesAndValuesSubCalls}, if thereWasAtleastOneSubCallOfCheckingReturnTypesAndValues == true then this success is not full because for one or more expression InstanceCreationInvokation constructor invokation param there was another \$() instance which required a nested checkingReturnTypesAndValues which mail detect type/value error or succeed, some data: return true comparisonResult == null||comparisonResult==false Two expression compared: expression = ${expression}, expression2 = ${expression2}');
          return checkingReturnTypesAndValuesSubCalls.contains(false)
              ? false
              : checkingReturnTypesAndValuesSubCalls.contains(null)
                  ? null
                  : true;
        }
      }

      if (expression != null ||
          expression2 != null ||
          diagnosticMessageNode != null) {
        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() are values compared equal?: value == value2: ${value == value2}');
      }
      return null;
      return value == value2;
    } else {
      if (expression != null ||
          expression2 != null ||
          diagnosticMessageNode != null) {
        addLintMessage(
            reporter,
            diagnosticMessageNode ?? expression ?? expression2!,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'compareValueFromUltimateExpressionWithAnotherUltimateValue() the two values compared are of instances that can\' be compared. The two values related record with all info look like this: value: $value, value2: $value2');
      }
      return null;
    }
  }

  /// returns true if all supplied expressions are allowed to be returned or false if one fails to meet at least one condition existing in the method call
  /// returns null if a syntax error like situation occurs with accompanying required return action.
  /// this method's return value is not necessary needed but is used in nested calls it helps to track where the problems occur.
  bool? checkingReturnTypesAndValues(
      ErrorReporter reporter,
      Map<dynamic, List<ReturnStatement>> returnStatements,
      Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId,
      Map<int, List<VariableDeclaration>> variableDeclarationsByElementId,
      MethodDeclaration methodDeclaration,
      List<Expression> expressions,
      Expando<Identifier>? topLevelIdentifiersProducingExpressions,
      // for nested calls:
      [DartObject? nestedCall$,
      InstanceCreationExpression? nestedCall$Expression]) {
    bool allExprssionsMeetRequirements = true;
    addLintMessage(
        reporter,
        methodDeclaration,
        msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
        'checkingReturnTypesAndValues: Entered stage #0 expressions.length = ${expressions.length} expressions = ${expressions}');
    for (int k = 0; k < expressions.length; k++) {
      final Expression expression = expressions[k];
      Expression messageNode = expression;
      addLintMessage(
          reporter,
          methodDeclaration,
          msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
          'checkingReturnTypesAndValues: Entered stage #1');
      addLintMessage(
          reporter,
          expression,
          msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
          'checkingReturnTypesAndValues: Entered stage #2');
      try {
        // the below line will throw if there is no element at all (so the last one too isn't);
        methodDeclaration.declaredElement?.metadata.last;
      } catch (e) {
        /// for readability and consistency variable is used (true)
        return allExprssionsMeetRequirements;
      }
      try {
        if (methodDeclaration.declaredElement == null) {
          continue;
        }
        final List<ElementAnnotation>? metad =
            methodDeclaration.declaredElement!.metadata;

        addLintMessage(
            reporter,
            methodDeclaration,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'checkingReturnTypesAndValues: Entered stage #3');
        addLintMessage(
            reporter,
            expression,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'checkingReturnTypesAndValues: Entered stage #3');
        if (metad != null &&
            metad.isNotEmpty &&
            metad.last.element?.displayName == "\$") {
          /// You never expect this to be null
          //NodeList<Expression>? metaAnnotationObjectArguments =
          //    $AnnotationsByElementId[metad.last.element?.id]
          //        ?.arguments
          //        ?.arguments;
          //if (metaAnnotationObjectArguments == null) {
          //  //addLintMessage(
          //  //    reporter,
          //  //    expression,
          //  //    msgDebugMode
          //  //        ? errors.ErrorSeverity.ERROR
          //  //        : errors.ErrorSeverity.INFO,
          //  //    'checkingReturnTypesAndValues: Entered stage #4.5 metaAnnotationObjectArguments can\'t be null');
          //}

          bool hasBeenExceptionForTheCurrentNode = false;

          DartObject? computedMetaObject =
              nestedCall$ ?? metad.last.computeConstantValue();
          if (computedMetaObject == null) continue;
          bool hasConditionSwitchedTo$NOT = false;
          bool hasConditionSwitchedTo$Nullable = false;
          bool hasConditionSwitchedTo$Mutable = false;
          bool theParamMatchesAtLeastOneTypeOrValueRequirements = false;
          bool
              thereWasAtLeastOneConditionElementBefore$NOTOr$IFOrEndOfTheCondition =
              false;
          bool
              theParamMatchesAtLeastOneTypeOrValueRequirementsOf$NOTPartOfTheCondition =
              false;
          bool? is$ = computedMetaObject.getField('is\$')?.toBoolValue();
          if (is$ != null && is$) {
            addLintMessage(
                reporter,
                expression,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                'checkingReturnTypesAndValues: Entered stage #5');
            TypeSystem typeSystem =
                methodDeclaration.declaredElement!.library.typeSystem;

            fieldsOf$InstanceLoop:
            for (int i = 1; i <= standardNumberOfFields; i++) {
              DartObject? currentField = computedMetaObject.getField('t$i');
              Expression? currentFieldExpression;
              if (!currentField!.isNull) {
                // if would be null a param would has been passed to the constructor so the argument wouln't be available.
                // even if null was passed the expression would be created, if so it wouldn't be used so ok anyway
                if (nestedCall$Expression == null) {
                  currentFieldExpression = methodDeclaration
                      .metadata[methodDeclaration.metadata.length - 1]
                      .arguments
                      ?.arguments[i - 1];
                } else {
                  currentFieldExpression =
                      nestedCall$Expression.argumentList.arguments[i - 1];
                }
              }
              if (currentField.isNull) {
                break;
              } else if (currentField.type.toString() != "Type") {
                /// $M(any qualifying expression, not Identifier only) not type but value/instance/literal, etc.
                bool isMutableValue =
                    false; // const is not required, f.e. a List eee = ['abc'] on declaration or (not and) first-and-the-only assignment is required but you can eee.add();
                /// not type but value/instance/literal, etc.
                /// $N(someIdentifier) also the final expression must be of Identifier with declared f.e. not int type but int?
                bool isNullableValue = false;
                bool isBetween = false;
                bool isRegExp = false;

                addLintMessage(
                    reporter,
                    expression,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'checkingReturnTypesAndValues: Entered stage #5.3, just before the while loop: currentFieldExpression == $currentFieldExpression, currentFieldExpression is InstanceCreationExpression == ${currentFieldExpression is InstanceCreationExpression}, currentFieldExpression.runtimeType == ${currentFieldExpression.runtimeType}, currentField?.type == ${currentField?.type} currentField?.type?.getDisplayString() == ${currentField?.type?.getDisplayString()} ');

                /// TODO: KEEP IT/LOGIC COMPATIBLE WITH getExpressionWithCustomComparisonRequirements
                /// related to isMutableValue and isNullableValue and possibly more in the future
                /// the only reason for this loop is that there may be an instance $N, $M and possibly more in the future
                /// and the $M $N instances are carriers of the real type or value
                /// $M(any qualifying expression, not Identifier only) not type but value/instance/literal, etc.
                /// $N(someIdentifier) also the final expression must be of Identifier with declared f.e. not int type but int?
                /// when $M or $N like instance the variables like isMutable isNullable defined above this loop get their values
                /// and because nesting is allowed for $N($M(someDeclaredVariable)) the continue mutableNullable: may repeat up to several times
                /// untile the real compared currentField and currentFieldExpression expression is reached.
                /// if no continue mutableNullable; is called at the end break mutableNullable; forcing the loop not to iterate twice
                while (true) {
                  if (currentField == null ||
                      currentField!.isNull ||
                      currentField!.type.toString() == "Type") {
                    addLintMessage(
                        reporter,
                        methodDeclaration,
                        errors.ErrorSeverity.ERROR,
                        'checkingReturnTypesAndValues() Error: at this stage only instance objects are allowed no Types, null values carried by currentField or a currentField that is null not DartObject.');
                    return false;
                  } else {
                    setUpNewFields() {
                      currentField = currentField!.getField('t1');
                      if (currentField != null) {
                        currentFieldExpression = (currentFieldExpression
                                as InstanceCreationExpression)
                            .argumentList
                            .arguments
                            .first;
                      } else {
                        currentFieldExpression = null;
                      }
                    }

                    addLintMessage(
                        reporter,
                        expression,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues: Entered stage #5.5, currentFieldExpression == $currentFieldExpression, currentFieldExpression is InstanceCreationExpression == ${currentFieldExpression is InstanceCreationExpression}, currentFieldExpression.runtimeType == ${currentFieldExpression.runtimeType}, currentField?.type == ${currentField?.type} currentField?.type?.getDisplayString() == ${currentField?.type?.getDisplayString()} ');

                    switch (currentField?.type?.getDisplayString()) {
                      case "\$M":
                        isMutableValue = true;
                        setUpNewFields();
                        continue;
                      case "\$N":
                        isNullableValue = true;
                        setUpNewFields();
                        continue;
                      case "\$B":
                        isBetween = true;
                        break;
                      case "\$R":
                        isRegExp = true;
                        break;
                    }
                  }
                  break;
                }
                if (isNullableValue || hasConditionSwitchedTo$Nullable) {
                  Identifier? theTopLevelAncestorIdentifier =
                      topLevelIdentifiersProducingExpressions?[expression];
                  if (theTopLevelAncestorIdentifier == null) {
                    /// not an error as i see - the expression match against a $() param just doesn't meet the required param condition
                    addLintMessage(
                        reporter,
                        methodDeclaration,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues() Error: theTopLevelAncestorIdentifier = ${theTopLevelAncestorIdentifier} Current expression == $expression, expression is expected to belong to an Indentifier instance but the indentifier was not found as the \$N(somerequiredexpressionOrIdentifierHavingExpression) need to work with identifiers and the identifier instance (int? abc = 10 - abc is Identifier() instance) with declared type that is nullable f.e. int? not int, List? not List. And in this particlular case (\$N(...)). But the expression inside \$N() will be matched with the current expression not with the ancestor Identifier');
                    continue;
                  } else {
                    addLintMessage(
                        reporter,
                        methodDeclaration,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues: theTopLevelAncestorIdentifier = ${theTopLevelAncestorIdentifier} isNullableValue == true but is the identifier defined as nullable type?: theTopLevelAncestorIdentifier.staticType?.nullabilitySuffix == NullabilitySuffix.question == ${theTopLevelAncestorIdentifier.staticType?.nullabilitySuffix == NullabilitySuffix.question} hence Some data: currentFieldExpression is! Identifier == ${currentFieldExpression is! Identifier} ${currentFieldExpression is! Identifier ? currentFieldExpression?.staticType : (currentFieldExpression as Identifier).staticType?.nullabilitySuffix} == ${currentFieldExpression is! Identifier ? currentFieldExpression?.staticType : (currentFieldExpression as Identifier).staticType?.nullabilitySuffix} currentFieldExpression.staticType == ${currentFieldExpression?.staticType}');
                    // FIXME: i expect this to contain info about nullabilitySuffix
                    // if not you have to go to the declaration variable and get info about the type - left hand or writeElement dont remember now
                    if (theTopLevelAncestorIdentifier
                            .staticType?.nullabilitySuffix !=
                        NullabilitySuffix.question) {
                      // not an error, just doesn't match the $() conditions for the current expression
                      addLintMessage(
                          reporter,
                          methodDeclaration,
                          msgDebugMode
                              ? errors.ErrorSeverity.ERROR
                              : errors.ErrorSeverity.INFO,
                          'checkingReturnTypesAndValues() info: Current expression which was to be mached against the \$N(somerequiredexpressionAlsoMayBeIdentifier) has it\'s own closest ancestor Identifier() instance but the ancestor identifier was not defined with a nullable type (int? abc = 10 - abc is Identifier() instance) with declared type that is nullable f.e. int? not int, List? not List. WARNING! Read doc // info above the place this message was defined, info on how to get the nullability info in different way if this was incorrect');
                      continue;
                    }
                  }
                }

                // TODO: we can try to get expression instead of DartObject to be able compare constructors, list, maps and sets not only DartObjects or simple type values like 2.8, "abc"
                // ((inv.argumentList.arguments.first.staticParameterElement?.metadata.first.element?.declaration as ClassMember) as FieldDeclaration).fields.variables.first.initializer;
                bool wasUsedComparisonResult2 = false;
                bool? comparisonResult;
                bool? comparisonResult2;
                try {
                  //addLintMessage(
                  //    reporter,
                  //    methodDeclaration,
                  //    msgDebugMode
                  //        ? errors.ErrorSeverity.ERROR
                  //        : errors.ErrorSeverity.INFO,
                  //    'checkingReturnTypesAndValues: the expression represents value. methodDeclaration.metadata.length = ${methodDeclaration.metadata.length}');
                  //addLintMessage(
                  //    reporter,
                  //    messageNode,
                  //    msgDebugMode
                  //        ? errors.ErrorSeverity.ERROR
                  //        : errors.ErrorSeverity.INFO,
                  //    'checkingReturnTypesAndValues: the expression represents value. ');
                  comparisonResult =
                      compareValueFromUltimateExpressionWithAnotherUltimateValue(
                          reporter,
                          returnStatements,
                          assignmentExpressionsByElementId,
                          variableDeclarationsByElementId,
                          expression: expression,
                          expressionMustBeConst: !(isMutableValue ||
                              hasConditionSwitchedTo$Mutable),
                          dartObjectParam2: currentField,
                          expressionParam2SupportFordartObjectParam2:
                              currentFieldExpression,
                          expression2MustBeConst2:
                              false, // currentField doesn't have to be const but on first and only value assignment calculable/readable final values must repeat for constructor, list/map/set/record literals,,
                          isBetween: isBetween,
                          isRegExp: isRegExp,
                          methodDeclaration: methodDeclaration);

                  if (!isBetween &&
                          !isRegExp &&
                          comparisonResult == null &&
                          currentFieldExpression != null
                      //&& methodDeclaration.metadata.length > 0 &&
                      //methodDeclaration
                      //    .metadata[methodDeclaration.metadata.length - 1]
                      //    .arguments
                      //    ?.arguments
                      //    .length is int &&
                      //methodDeclaration
                      //        .metadata[methodDeclaration.metadata.length - 1]
                      //        .arguments!
                      //        .arguments
                      //        .length >=
                      //    i - 1 &&
                      //methodDeclaration
                      //        .metadata[methodDeclaration.metadata.length - 1]
                      //        .arguments
                      //        ?.arguments[i - 1] !=
                      //    null
                      ) {
                    wasUsedComparisonResult2 = true;
                    addLintMessage(
                        reporter,
                        methodDeclaration,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues: comparing with comparisonResult2 : expression: ${methodDeclaration.metadata[methodDeclaration.metadata.length - 1].arguments?.arguments[i - 1]}');
                    addLintMessage(
                        reporter,
                        messageNode,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues: comparing with comparisonResult2 : expression: ${methodDeclaration.metadata[methodDeclaration.metadata.length - 1].arguments?.arguments[i - 1]}');

                    comparisonResult2 =
                        compareValueFromUltimateExpressionWithAnotherUltimateValue(
                            reporter,
                            returnStatements,
                            assignmentExpressionsByElementId,
                            variableDeclarationsByElementId,
                            expression: expression,
                            expressionMustBeConst: !(isMutableValue ||
                                hasConditionSwitchedTo$Mutable),
                            expression2:
                                currentFieldExpression // to remind you in the previous method call getField was used but it failed so we use this corresponding expression
                            ,
                            dartObjectParam2SupportForExpression2: currentField,
                            expression2MustBeConst2:
                                false, // expression corresponding to getField doesn't have to be const but on first and only value assignment calculable/readable final values must repeat for constructor, list/map/set/record literals,
                            //isBetween: isBetween,
                            //isRegExp: isRegExp
                            diagnosticMessageNode: methodDeclaration,
                            methodDeclaration: methodDeclaration);
                  }
                } catch (e, stackTrace) {
                  addLintMessage(
                      reporter,
                      methodDeclaration,
                      errors.ErrorSeverity.ERROR,
                      'checkingReturnTypesAndValues() catched error/exception: i==$i (meta = i but Annotation argument has index i-1) e = $e, stackTrace $stackTrace');
                  addLintMessage(
                      reporter,
                      messageNode,
                      errors.ErrorSeverity.ERROR,
                      'checkingReturnTypesAndValues() catched error/exception: i==$i (meta = i but Annotation argument has index i-1) e = $e, stackTrace $stackTrace');
                  //'checkingReturnTypesAndValues() catched error: metaAnnotationObjectArguments= ${metaAnnotationObjectArguments}, e = $e, stackTrace $stackTrace');
                  continue;
                }

                addLintMessage(
                    reporter,
                    methodDeclaration,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'checkingReturnTypesAndValues() INFO WHAT WE HAVE` expressions compared: $expression, $currentField. comparisonResult = ${comparisonResult}, comparisonResult2 = ${comparisonResult2}, wasUsedComparisonResult2 = $wasUsedComparisonResult2, isBetween: $isBetween, isRegExp: $isRegExp');
                addLintMessage(
                    reporter,
                    messageNode,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'checkingReturnTypesAndValues() INFO WHAT WE HAVE` expressions compared: $expression, $currentField. comparisonResult = ${comparisonResult}, comparisonResult2 = ${comparisonResult2}, wasUsedComparisonResult2 = $wasUsedComparisonResult2, isBetween: $isBetween, isRegExp: $isRegExp');

                // FIXME: When using the code from danno_script_lints_discovery_lab.dart (or danno_script_lints_discovery_lab.dart?) somewhere else take into account that
                // "syntax" instances $IF() $THEN() don't allow for thereWasAtLeastOneConditionElementBefore$NOTOr$IFOrEndOfTheCondition = true;
                // which is reserved for normal values - literals, variables
                // but there maybe $BETWEEN(5, 10) IMPLEMENTED IN THE FUTURE it won't be "syntax" instance
                if (!hasConditionSwitchedTo$NOT) {
                  thereWasAtLeastOneConditionElementBefore$NOTOr$IFOrEndOfTheCondition =
                      true;
                }
                if (comparisonResult == true) {
                  addLintMessage(
                      reporter,
                      messageNode,
                      msgDebugMode
                          ? errors.ErrorSeverity.ERROR
                          : errors.ErrorSeverity.INFO,
                      'checkingReturnTypesAndValues() comparisonResult the expression is not type so it should be a value to be compared like 0.345 or an instance of some class SomeClass()');
                  if (hasConditionSwitchedTo$NOT) {
                    addLintMessage(
                        reporter,
                        messageNode,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues() comparisonResult the expression matches value (not type) at least one \$() NOT CONDITION (after \$NOT)');
                    theParamMatchesAtLeastOneTypeOrValueRequirementsOf$NOTPartOfTheCondition =
                        true;
                  } else {
                    addLintMessage(
                        reporter,
                        messageNode,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues() comparisonResult the expression matches value (not type) at least one \$() NORMAL (not after \$NOT) CONDITION');
                    theParamMatchesAtLeastOneTypeOrValueRequirements = true;
                  }
                } else if (comparisonResult2 == true) {
                  addLintMessage(
                      reporter,
                      messageNode,
                      msgDebugMode
                          ? errors.ErrorSeverity.ERROR
                          : errors.ErrorSeverity.INFO,
                      'checkingReturnTypesAndValues() comparisonResult2 the expression is not type so it should be a value to be compared like 0.345 or an instance of some class SomeClass()');
                  if (hasConditionSwitchedTo$NOT) {
                    addLintMessage(
                        reporter,
                        messageNode,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues() comparisonResult2 the expression matches value (not type) at least one \$() NOT CONDITION (after \$NOT)');
                    theParamMatchesAtLeastOneTypeOrValueRequirementsOf$NOTPartOfTheCondition =
                        true;
                  } else {
                    addLintMessage(
                        reporter,
                        messageNode,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'checkingReturnTypesAndValues() the expression matches value (not type) at least one \$() NORMAL (not after \$NOT) CONDITION');
                    theParamMatchesAtLeastOneTypeOrValueRequirements = true;
                  }
                } else {
                  // nothing bad comparisonResult and ...2 are null or false - just doesn't match
                  // if there were dart anno types "syntax" errors (f.e. $B(3, 1) 3 must be less than the second param) along the way they already were added as addLintMessage.
                  addLintMessage(
                      reporter,
                      messageNode,
                      msgDebugMode
                          ? errors.ErrorSeverity.ERROR
                          : errors.ErrorSeverity.INFO,
                      'checkingReturnTypesAndValues() comparisonResult = ${comparisonResult}, comparisonResult2 = ${comparisonResult2}, wasUsedComparisonResult2 = $wasUsedComparisonResult2, comparisonResult == null||comparisonResult==false which means for null the result was not comparable because of Expression types not handled yet (not implemented, or "impossible" to handle), or expressions are of different types, or if == false two expressions/objects were compared successfuly but not equal. Old (maybe not up to date) error info: Sort of Syntax Error due to the difficulty with implementing all features, to avoid this problem use only variable names (maybe required to be const (verify)) instead of direct values like [10, 20], but you can use 10, 2.5, \'abc\' not \'abc\$name wer\'. Also try to check out if some other types like the mentioned [10, 20] - handling them havent\'t been in the incoming versions, implemented At least one value hasn\'t been found or both values were found but one of them was received from Instance() object but te second from a DartObject?, while for a values like int it is not a problem, but for List or SomeClass() instance at the time of writig this message the two objects are represented by two different class instances. It is practical to temporary set up theParamMatchesAtLeastOneTypeOrValueRequirementsOf\$NOTPartOfTheCondition = true; how to fixit? expression causing problem: $expression, $currentField.');

                  /// ??? was: theParamMatchesAtLeastOneTypeOrValueRequirementsOf$NOTPartOfTheCondition = true;
                }
              } else {
                // .valueHasBeenFound == null changes the meaning of potential null of value.value below:
                // isTheValueOfExpressionNull is null when not set up at all becaue the first if statement (hasExpressionTypeNullabilitySuffix)
                // Why it is not a problem when the value was not found value.value value is not calculable,
                // only for value.value == null it is always calculable;
                // we know that because HERE we work on ultimate non-conditional final expressions where there is a type known:
                // such an non-ultimate expression looks like this:
                // int? abc = 20 + unknownNonConstantValue;
                // abc ?? cde == null? null:2.5;
                // the ultimate expressions we work here is abc, null and 2.5
                // getting the null will never fail.
                // 2.5 we know it is double but we don't need it's computed value.
                // abc is uncalculable but we know it is int as 20 + anything is always int
                // also unknownNonConstantValue + 20 is not null but as the declared type of abc is int? we know it must be int because you if unknownNonConstantValue == null then you can't add null + 20
                // FIXME:
                // [Last edit:] The final decision must be:
                // the each ultimate expression (List<[ultimate]Expression)) from a variable must be taken.
                // Types: Both for const and and variable. Because the declared num? might be be null, int, double but $($NOT double) says it all,
                // Values: it doesn't matter
                // [Edit:] not sufficient sleep: the below is not a problem as all variables have calculated value
                // because of that you know if the value is null value or something else
                // if something else it is calculated and get the underlying type
                // but while it is true you can't get it's underlying type? to be compared here? guite a puzzle.
                // FIXME: FIXME: PROBABLY FOUND THE BEST WAY TO SOLVE THE PROBLEM:
                // LITERALS USE FOR F.E. LIST AND MAP also CollectionElement IT TURNS OUT Expression is implementing CollectionElement
                // and while collection element might be ForElement and more only non expression element classes
                // but literal probably it is only [Expression].
                // SO IS there a CHANCE TO COMPARE IT WITH Itendtifier() BECAUSE
                // Identifier() has .elements here each has [CollectionElement] and each rather "must" have Expression.
                // But as i see two the same looking expressions might produce different values if a const [const1, const2] or variable with the same name produces different values
                // !!! No? Possibly if you have NodeList<CollectionElement> for Identifier and ListLiteral
                // !!! No? you might try to compare it with eqal ==
                // what of instance of SomeClass()?
                // we have InstanceCreationExpression(): f.e. expression.unParenthesized;
                // then we have Itentifier which has elements CollectionElements (assuming is also Expression)
                // it might be one element (can be more?)
                // BUT WE CANNOT COMPUTE IT AS WITH LIST AND MAP AND SET WE CAN'T
                // SO PROBABLY IT'S A MESS.
                // THE ONLY WAY IT COULD BE DONE IS
                // WHEN ALL COLLECTION ELEMENTS ARE CALCULATE LIKE [10, 2.8, 'some stRING', $constValueMaybeAAAAAAAAAAAAAAAAaa, SomeOtherClass()] (MAYBE LATER "STRING $a"),
                // possibly also constructors with params like SomeClass(10, 2.8, 'some stRING', $constValueMaybe) (MAYBE LATER "STRING $a"),
                // SomeClass(10, 2.8, 'some stRING', constValueMaybeAAAAAAAAAAAAAAAAaa, SomeOtherClass())
                // SomeClass(10, 2.8, 'some stRING', constValueMaybeBBBBBBBBBBBBBBBBBBB, SomeOtherClass())
                // constValueMaybeAAAAAAAAAAAAAAAAaa....computeConstantValue()! == $constValueMaybeBBBBBBBBBBBBBBBBBBB....computeConstantValue()!
                // probably no need to check .isNull but make sure it returns for DartObject the same for isDartCoreInt for example like for non-typically-handled values.
                // HOW COULD IT BE DONE FOR EACH COLLECTION ELEMENT:
                // getUltimateNonConditionalNorSwitchExpressions GETS YOU EXPRESSIONS IN A UNIQUE ORDER
                // SO BOTH COMARABLE each collectoin element expression must be equal if it is SomceClass(...) then the params are like collection elements so the list of returned expressions from the constructor must be comparable with other object - in the right order.
                // SO WE KINDA VERY CLOSE TO SOLVE THE PROBLEM.
                // IT COULD BE SO BECAUSE such constructed instances procuce always the same object (our value) exactly of the same class (class name must agree - dont know if cast as is a problem.).
                // Also instances don't have to be created like const SomeClass - it is important that the constructor declaration is preceded with const.
                // ======================
                // I just noticed then that you may or may not have to calculate the the non-null type of unknownNonConstantValue;
                // of course not simple int? but maybe Object? but it is String or List or SomeClass
                // we haven't broke it down, did we?
                // this is the only spot where we have to ignore declared type like Object?
                // and get the final type of expression itself to get closer types
                //
                // REVISE IT AGAIN
                // FIXME: END.
                // so analyzer does it for you but this is breaking down the logic
                // So the final expression is not null so the following correct:
                addLintMessage(
                    reporter,
                    messageNode,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'checkingReturnTypesAndValues() the \$ constructor argument is type: currentField = ${currentField}, currentField.type = ${currentField.type} currentField!.toTypeValue()!.getDisplayString() = ${currentField!.toTypeValue()!.getDisplayString()}, typeSystem.isSubtypeOf(expression.staticType!, currentField!.toTypeValue()!) = ${typeSystem.isSubtypeOf(expression.staticType!, currentField!.toTypeValue()!)}');

                String typeValueString =
                    currentField!.toTypeValue()!.getDisplayString();
                // null when not set up:
                bool? isTheValueOfExpressionNull;

                if (typeValueString == "Null") {
                  // we have to check if it is just null, and fortunatelly you can calculate it whether it is Itentifier or BooleanLiteral (Literal)
                  var value = getComparableValueFromExpressionOrDartObject(
                      reporter,
                      returnStatements,
                      assignmentExpressionsByElementId,
                      variableDeclarationsByElementId,
                      expression);
                  if (value.valueHasBeenFound && value.value == null) {
                    isTheValueOfExpressionNull = true;
                  } else {
                    isTheValueOfExpressionNull == false;
                  }
                }

                //typeSystem.promoteToNonNull();
                addLintMessage(reporter, messageNode, errors.ErrorSeverity.INFO,
                    'checkingReturnTypesAndValues meta param value is Type. isTheValueOfExpressionNull = $isTheValueOfExpressionNull, typeSystem.isSubtypeOf(expression.staticType!, currentField.toTypeValue()!) = ${typeSystem.isSubtypeOf(expression.staticType!, currentField!.toTypeValue()!)} , expression.staticType = ${expression.staticType}, currentField.toTypeValue() = ${currentField!.toTypeValue()}');
                if (expression.staticType == null) {
                  addLintMessage(
                      reporter,
                      messageNode,
                      errors.ErrorSeverity.ERROR,
                      'checkingReturnTypesAndValues Error: it is unexpected that expression.staticType == null');
                  return null;
                }
                if (typeValueString == '\$NOT') {
                  hasConditionSwitchedTo$NOT = true;
                  hasConditionSwitchedTo$Nullable = false;
                  hasConditionSwitchedTo$Mutable = false;
                } else if (typeValueString == '\$N') {
                  hasConditionSwitchedTo$Nullable = true;
                } else if (typeValueString == '\$M') {
                  hasConditionSwitchedTo$Mutable = true;
                } else if ((typeValueString == "Null" &&
                        isTheValueOfExpressionNull == true) ||
                    typeSystem.isSubtypeOf(
                        expression.staticType!, currentField!.toTypeValue()!)) {
                  if (hasConditionSwitchedTo$NOT) {
                    theParamMatchesAtLeastOneTypeOrValueRequirementsOf$NOTPartOfTheCondition =
                        true;
                    addLintMessage(
                        reporter,
                        messageNode,
                        errors.ErrorSeverity.INFO,
                        'info: after \$NOT matches: expression = ${expression}, currentField.type = ${currentField!.type}');
                  } else {
                    addLintMessage(
                        reporter,
                        messageNode,
                        errors.ErrorSeverity.INFO,
                        'info: before \$NOT matches: expression = ${expression}, currentField.type = ${currentField!.type}');
                    theParamMatchesAtLeastOneTypeOrValueRequirements = true;
                  }
                } else {
                  if (!hasConditionSwitchedTo$NOT) {
                    thereWasAtLeastOneConditionElementBefore$NOTOr$IFOrEndOfTheCondition =
                        true;
                  }
                }
              }
            }

            if (theParamMatchesAtLeastOneTypeOrValueRequirementsOf$NOTPartOfTheCondition ||
                (!theParamMatchesAtLeastOneTypeOrValueRequirements &&
                    thereWasAtLeastOneConditionElementBefore$NOTOr$IFOrEndOfTheCondition)) {
              allExprssionsMeetRequirements = false;
              addLintMessage(reporter, messageNode, errors.ErrorSeverity.ERROR,
                  'Error: A return statement expression/value is not of required type nor value, if expression is complex with possible multiple ulitmate possible value returns i means that at least one of the sub values is not meeting the expectations of a returned value: expression = ${expression.toSource()}, theParamMatchesAtLeastOneTypeOrValueRequirementsOf\$NOTPartOfTheCondition = ${theParamMatchesAtLeastOneTypeOrValueRequirementsOf$NOTPartOfTheCondition}, theParamMatchesAtLeastOneTypeOrValueRequirements = $theParamMatchesAtLeastOneTypeOrValueRequirements, thereWasAtLeastOneConditionElementBefore\$NOTOr\$IFOrEndOfTheCondition = ${thereWasAtLeastOneConditionElementBefore$NOTOr$IFOrEndOfTheCondition}');
            } else {
              addLintMessage(
                  reporter,
                  messageNode,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'Success (overall): A return statement expression/value is of required type or value,: expression = ${expression.toSource()} allExprssionsMeetRequirements == $allExprssionsMeetRequirements');
            }
          }
        }
      } catch (e, stackTrace) {
        addLintMessage(reporter, methodDeclaration, errors.ErrorSeverity.ERROR,
            'Lint plugin exception: $e $stackTrace');
      }
    }
    return allExprssionsMeetRequirements;
  }

  /// this calls [getUltimateNonConditionalNorSwitchExpressions] in a way that the returned value by
  /// this getUltimateConstLikeExpressions method is null when a conditional expression exp?true : false was found
  /// or similar more o less advanced expressions that cannot produce one 100%-statically-known expression
  /// Warning! while expression like constructor invokation will be returned it will be checked if it has const constructor,
  /// the same is planned for list, set and map literals
  ({
    List<Expression> expressions,
    Expando<Identifier>? topLevelIdentifiersProducingExpressions,
    bool wasThereAnyEmptyReturnStatement,
    bool wasThereAnyEmptyFunctionBody,
  })? getUltimateConstLikeExpressions(
    ErrorReporter reporter,
    Map<dynamic, List<ReturnStatement>> returnStatements,
    Map<int, List<VariableDeclaration>> variableDeclarationsByElementId,
    Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId,
    Expression expression,
    Expando<Identifier>? topLevelIdentifiersProducingExpressionsSupplied,
  ) {
    try {
      return getUltimateNonConditionalNorSwitchExpressions(
          reporter,
          returnStatements,
          variableDeclarationsByElementId,
          assignmentExpressionsByElementId,
          expression,
          topLevelIdentifiersProducingExpressionsSupplied,
          true);
    } catch (e) {
      return null;
    }
  }

  /// if throwOnConditionalLikeOrFunction == true (used only by [getUltimateConstLikeExpressions] which catches and returns null)
  /// then we want to get only results that has knows value - 2.8, 'abc', SomeConstructor(...) but not a functin/method call.
  /// but for default false we can get f.e. possible known/comparable return values that can be returned during runtime time not static code analysis time.
  /// null is returned if failOnConditional == true and and a conditional, binary,
  /// or function/method-like expression invokation was found which can't guarantee the const-like result (TODO: in future some difficult to implement exceptions could be added if time allows for the little-benefit implementation)
  /// Warning null means that the expression or in a tree of subexpressions there was a "return;" statement with void return;
  /// An expression can be condition?10:false - the possible ultimate expressions are 10: false and their types are 10 and int
  /// but condition?10:(condition2?false:'abc') is nested and possible values and types are 10/int, false/bool, 'abc'/String
  /// This method is not for getting the final types and computed const values (if they are computable).
  ({
    List<Expression> expressions,
    Expando<Identifier>? topLevelIdentifiersProducingExpressions,
    bool wasThereAnyEmptyReturnStatement,
    bool wasThereAnyEmptyFunctionBody,
  }) getUltimateNonConditionalNorSwitchExpressions(
      ErrorReporter reporter,
      Map<dynamic, List<ReturnStatement>> returnStatements,
      Map<int, List<VariableDeclaration>> variableDeclarationsByElementId,
      Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId,
      Expression expression,
      [Expando<Identifier>? topLevelIdentifiersProducingExpressionsSupplied,
      // below param to be used only by getUltimateConstLikeExpressions
      bool throwOnConditionalLikeOrFunctionOrPossibleIdentifierMultipleAssignmentExpressions =
          false]) {
    Expando<Identifier> topLevelIdentifiersProducingExpressions =
        topLevelIdentifiersProducingExpressionsSupplied ??
            Expando<Identifier>();
    try {
      ParenthesizedExpression; // .expression;
      ConditionalExpression; // probably including version "??"" and with .thenExpression, .elseExpression
      SwitchExpression; // .cases which are NodeList<SwitchExpressionCase> .expression for a case;
      List<Expression> expressions = [];
      List<Expression> iterationExpressions = [expression.unParenthesized];
      bool wasThereAnyEmptyReturnStatement = false;
      bool wasThereAnyEmptyFunctionBody = false;
      while (true) {
        List<Expression> nextIterationExpressions = [];
        if (iterationExpressions.isEmpty) {
          break;
        }
        for (int i = 0; i < iterationExpressions.length; i++) {
          //if (iterationExpressions[i] is ParenthesizedExpression) {
          //  var subExpression = iterationExpressions[i];
          //  while (true) {
          //    subExpression =
          //        (subExpression as ParenthesizedExpression).expression;
          //    if (subExpression is! ParenthesizedExpression) {
          //      nextIterationExpressions.add(subExpression);
          //      break;
          //    }
          //  }
          //}

          if (iterationExpressions[i] is Identifier) {
            //topLevelIdentifiersProducingExpressions[assignmentExpression.unParenthesized]=iterationExpressions[i] as Identifier;
            Identifier? theTopLevelAncestorIdentifier =
                topLevelIdentifiersProducingExpressions[
                    iterationExpressions[i]];

            if (throwOnConditionalLikeOrFunctionOrPossibleIdentifierMultipleAssignmentExpressions) {
              // to remind you if more than one possible assigned values could be found for an identifier during it's lifetime
              // vlaue.valueHasBeenFound == false
              var value = getComparableValueFromExpressionOrDartObject(
                  reporter,
                  returnStatements,
                  assignmentExpressionsByElementId,
                  variableDeclarationsByElementId,
                  iterationExpressions[i]);
              if (!value.valueHasBeenFound ||
                  value.value == null ||
                  value.value!.isEmpty ||
                  value.value![ComparableUltimateValue.expression] == null) {
                throw Exception(
                    'getUltimateNonConditionalNorSwitchExpressions(), there is no need for this exception to be handled becuse it was originally to be used only by getUltimateConstLikeExpressions() method');
              } else {
                topLevelIdentifiersProducingExpressions[
                    value.value![ComparableUltimateValue.expression]
                        as Expression] = theTopLevelAncestorIdentifier ??
                    iterationExpressions[i] as Identifier;
                nextIterationExpressions.add(value
                    .value![ComparableUltimateValue.expression] as Expression);
              }
            } else {
              //var identifier = iterationExpressions[i] as Identifier;
              //identifier.
              //
              //nextIterationExpressions.add(
              //    (iterationExpressions[i] as ConditionalExpression)
              //        .thenExpression);
              //nextIterationExpressions.add(
              //    (iterationExpressions[i] as ConditionalExpression)
              //        .elseExpression);
              final Identifier expression =
                  iterationExpressions[i] as Identifier;
              DartObject? dartObject;
              String msg = '';
              dynamic element;
              if (expression.staticElement is VariableElement) {
                (expression.staticElement as VariableElement).declaration;
                var elem = (expression.staticElement as VariableElement);
                element = elem;
                msg +=
                    'getUltimateNonConditionalNorSwitchExpressions() VariableElement elema.id = ${elem.id}, elema.nonSynthetic.id = ${elem.nonSynthetic.id}';

                dartObject = (expression.staticElement as VariableElement)
                    .computeConstantValue();
              }

              if (expression.staticElement is PropertyAccessorElement) {
                var elem =
                    (expression.staticElement as PropertyAccessorElement);
                element = elem;
                var variable2 = elem.variable2;
                dartObject = variable2?.computeConstantValue();
                var variable2_variety = elem.variable2?.getter?.variable2;
                var dartObject_variety = variable2?.computeConstantValue();

                msg +=
                    'getUltimateNonConditionalNorSwitchExpressions() PropertyAccessorElement elema.id = ${elem.id}, elema.nonSynthetic.id = ${elem.nonSynthetic.id}';

                msg +=
                    'getUltimateNonConditionalNorSwitchExpressions() PropertyAccessorElement variable2=${variable2} getter = ${variable2?.getter}, variable2?.getter?.hasImplicitReturnType = ${variable2?.getter?.hasImplicitReturnType}, dartObject?.type = ${dartObject?.type} dartObject?.type?.isDartCoreInt = ${dartObject?.type?.isDartCoreInt} ${dartObject} ';
                msg +=
                    'getUltimateNonConditionalNorSwitchExpressions() PropertyAccessorElement variable2_variety=${variable2_variety} getter = ${variable2_variety?.getter}, variable2_variety?.getter?.hasImplicitReturnType = ${variable2_variety?.getter?.hasImplicitReturnType}, dartObject_variety?.type = ${dartObject_variety?.type} dartObject_variety?.type?.isDartCoreInt = ${dartObject_variety?.type?.isDartCoreInt} ${dartObject_variety} ';
                //if (elem.variable2.getter.hasImplicitReturnType) {
                //  //elem.variable2.
                //}
              }

              //variableDeclarationsByElementId[variableDeclaration.declaredElement!.id];

              //variableDeclarationsByElementId[
              //    variableDeclaration.declaredElement!.id];

              List<VariableDeclaration> variableDeclarations = [];
              if (element != null &&
                  variableDeclarationsByElementId[element.nonSynthetic.id] !=
                      null &&
                  variableDeclarationsByElementId[element.nonSynthetic.id]!
                      .isNotEmpty) {
                variableDeclarations =
                    variableDeclarationsByElementId[element.nonSynthetic.id]!;

                msg +=
                    'getUltimateNonConditionalNorSwitchExpressions() we\'ve found a declaraition for this variable, because if is allowed that this variable not to have have to be const, so we don\'t know which declaration/assigment with its expression was used for this variable and we must check all a declaration + assignments of this variable - each d/assigment\'s possible type(s) or/and values(s) allowed. variableDeclarations = ${variableDeclarations}';
              } else {
                msg +=
                    'getUltimateNonConditionalNorSwitchExpressions() we haven\'t found a declaraition for this variable, variableDeclarations = ${variableDeclarations}';
              }

              variableDeclarations
                  .forEach((VariableDeclaration variableDeclaration) {
                if (variableDeclaration.initializer == null) {
                  return;
                }
                // if a function/method was called with a not initialized variable dart has own error for that
                if (variableDeclaration.initializer != null)
                  nextIterationExpressions
                      .add(variableDeclaration.initializer!.unParenthesized);
                topLevelIdentifiersProducingExpressions[
                        variableDeclaration.initializer!.unParenthesized] =
                    theTopLevelAncestorIdentifier ??
                        iterationExpressions[i] as Identifier;
              });

              List<AssignmentExpression> assignmentExpressions = [];
              if (element != null &&
                  assignmentExpressionsByElementId[element.nonSynthetic.id] !=
                      null &&
                  assignmentExpressionsByElementId[element.nonSynthetic.id]!
                      .isNotEmpty) {
                assignmentExpressions =
                    assignmentExpressionsByElementId[element.nonSynthetic.id]!;
                msg +=
                    'getUltimateNonConditionalNorSwitchExpressions() we\'ve found all assignments (apart from a declaration) for this variable, because if is allowed that this variable not to have have to be const, so we don\'t know which assigment with its expression was used for this variable and we must check all assignments of this variable - each assigment\'s possible type(s) or/and values(s) allowed. assignmentExpressions = ${assignmentExpressions}';
              } else {
                msg +=
                    'getUltimateNonConditionalNorSwitchExpressions() we haven\'t found any assignments (added to a possible declaration if found) with optional assignments for this variable, assignmentExpressions = ${assignmentExpressions}';
              }

              assignmentExpressions
                  .forEach((AssignmentExpression assignmentExpression) {
                nextIterationExpressions
                    .add(assignmentExpression.unParenthesized);
                topLevelIdentifiersProducingExpressions[
                        assignmentExpression.unParenthesized] =
                    theTopLevelAncestorIdentifier ??
                        iterationExpressions[i] as Identifier;
              });

              addLintMessage(reporter, expression, errors.ErrorSeverity.INFO,
                  'getUltimateNonConditionalNorSwitchExpressions() msg = $msg, it is Identifier(). dartObject.type?.isDartCoreInt = ${dartObject?.type?.isDartCoreInt}, dartObject = ${dartObject}, ${expression.staticElement is VariableElement}, ${expression.runtimeType}, ${expression.staticElement?.runtimeType}, ${expression.staticElement}');
            }
          } else if (iterationExpressions[i] is ConditionalExpression) {
            if (throwOnConditionalLikeOrFunctionOrPossibleIdentifierMultipleAssignmentExpressions) {
              throw Exception(
                  'getUltimateNonConditionalNorSwitchExpressions(), there is no need for this exception to be handled becuse it was originally to be used only by getUltimateConstLikeExpressions() method');
            }
            //topLevelIdentifiersProducingExpressions[assignmentExpression.unParenthesized]=iterationExpressions[i] as Identifier;
            Identifier? theTopLevelAncestorIdentifier =
                topLevelIdentifiersProducingExpressions[
                    iterationExpressions[i]];
            if (theTopLevelAncestorIdentifier != null) {
              topLevelIdentifiersProducingExpressions[
                  (iterationExpressions[i] as ConditionalExpression)
                      .thenExpression
                      .unParenthesized] = theTopLevelAncestorIdentifier;
              topLevelIdentifiersProducingExpressions[
                  (iterationExpressions[i] as ConditionalExpression)
                      .elseExpression
                      .unParenthesized] = theTopLevelAncestorIdentifier;
            }

            nextIterationExpressions.add(
                (iterationExpressions[i] as ConditionalExpression)
                    .thenExpression
                    .unParenthesized);
            nextIterationExpressions.add(
                (iterationExpressions[i] as ConditionalExpression)
                    .elseExpression
                    .unParenthesized);
          } else if (iterationExpressions[i] is SwitchExpression) {
            //topLevelIdentifiersProducingExpressions[assignmentExpression.unParenthesized]=iterationExpressions[i] as Identifier;
            Identifier? theTopLevelAncestorIdentifier =
                topLevelIdentifiersProducingExpressions[
                    iterationExpressions[i]];
            if (throwOnConditionalLikeOrFunctionOrPossibleIdentifierMultipleAssignmentExpressions) {
              throw Exception(
                  'getUltimateNonConditionalNorSwitchExpressions(), there is no need for this exception to be handled becuse it was originally to be used only by getUltimateConstLikeExpressions() method');
            }
            var cases = (iterationExpressions[i] as SwitchExpression).cases;
            for (int k = 0; k < cases.length; k++) {
              if (theTopLevelAncestorIdentifier != null) {
                topLevelIdentifiersProducingExpressions[cases[k]
                    .expression
                    .unParenthesized] = theTopLevelAncestorIdentifier;
              }
              nextIterationExpressions.add(cases[k].expression.unParenthesized);
            }
          } else if (iterationExpressions[i] is InvocationExpression) {
            //topLevelIdentifiersProducingExpressions[assignmentExpression.unParenthesized]=iterationExpressions[i] as Identifier;
            Identifier? theTopLevelAncestorIdentifier =
                topLevelIdentifiersProducingExpressions[
                    iterationExpressions[i]];
            // it CAN'T (CAN'T) BE InstanceCreationExpression

            if (throwOnConditionalLikeOrFunctionOrPossibleIdentifierMultipleAssignmentExpressions) {
              throw Exception(
                  'getUltimateNonConditionalNorSwitchExpressions(), there is no need for this exception to be handled becuse it was originally to be used only by getUltimateConstLikeExpressions() method');
            }

            addLintMessage(
                reporter,
                expression,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 1');
            if (iterationExpressions[i] is MethodInvocation) {
              addLintMessage(reporter, expression, errors.ErrorSeverity.ERROR,
                  'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 2');
              var methodInv = iterationExpressions[i] as MethodInvocation;
              if (methodInv.function is! MethodDeclaration) {
                addLintMessage(reporter, expression, errors.ErrorSeverity.ERROR,
                    'getUltimateNonConditionalNorSwitchExpressions() methodInv intuitively shouldn\'t be error here: error methodInv.function is! MethodDeclaration ${methodInv.function.runtimeType} ${methodInv.function.toString()} ${methodInv.function.toSource()}');
                continue;
              }
              var methodDeclaration = (methodInv.function as MethodDeclaration);
              int? id = (methodInv.function as MethodDeclaration)
                  .declaredElement
                  ?.declaration
                  .id;
              var returnStatementList = returnStatements[id];
              if (returnStatementList == null) {
                addLintMessage(
                    reporter,
                    expression,
                    errors.ErrorSeverity.WARNING,
                    'getUltimateNonConditionalNorSwitchExpressions() methodInv we are iteration through return expressions, in the return we don\'t have any ReturnStatement instances for this method. it is warning, but is it an error problem?');
              } else {
                addLintMessage(reporter, expression, errors.ErrorSeverity.ERROR,
                    'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 3');
                //[BlockFunctionBody] | [EmptyFunctionBody] | [ExpressionFunctionBody] | [NativeFunctionBody]
                if (methodDeclaration.body is ExpressionFunctionBody) {
                  addLintMessage(
                      reporter,
                      expression,
                      errors.ErrorSeverity.ERROR,
                      'getUltimateNonConditionalNorSwitchExpressions() methodInv returned value is ExpressionFunctionBody not a BlockFunctionBody with ReturnStatements, how much final expressions does the returned value?: ${getUltimateNonConditionalNorSwitchExpressions(reporter, returnStatements, variableDeclarationsByElementId, assignmentExpressionsByElementId, (methodDeclaration.body as ExpressionFunctionBody).expression)}');
                }
                for (int k = 0; k < returnStatementList.length; k++) {
                  if (returnStatementList[k].expression == null) {
                    addLintMessage(
                        reporter,
                        expression,
                        errors.ErrorSeverity.ERROR,
                        'getUltimateNonConditionalNorSwitchExpressions() methodInv we are iteration through return expressions, in the return logically should never be a void return call like return () {}(); rather (){}();return;, there must be an expression; such a situation should never happen but for now null is accepted, that at least one return was so.');
                  }
                  if (returnStatementList[k].expression != null) {
                    if (theTopLevelAncestorIdentifier != null) {
                      topLevelIdentifiersProducingExpressions[
                          returnStatementList[k]
                              .expression!
                              .unParenthesized] = theTopLevelAncestorIdentifier;
                    }
                    nextIterationExpressions.add(
                        returnStatementList[k].expression!.unParenthesized);
                  } else {
                    wasThereAnyEmptyReturnStatement = true;
                  }
                }
              }
            } else if (iterationExpressions[i]
                is FunctionExpressionInvocation) {
              //topLevelIdentifiersProducingExpressions[assignmentExpression.unParenthesized]=iterationExpressions[i] as Identifier;
              Identifier? theTopLevelAncestorIdentifier =
                  topLevelIdentifiersProducingExpressions[
                      iterationExpressions[i]];
              addLintMessage(
                  reporter,
                  expression,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 5');

              var functionInv =
                  iterationExpressions[i] as FunctionExpressionInvocation;
              if (functionInv.function is! FunctionExpression) {
                addLintMessage(
                    reporter,
                    expression,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'getUltimateNonConditionalNorSwitchExpressions() functionInv; intuitively shouldn\'t be error here: error methodInv.function is! FunctionDeclaration ${functionInv.function.runtimeType} ${(functionInv.function as FunctionExpression).declaredElement?.id} ${functionInv.function.toString()} ${functionInv.function.toSource()}  ${functionInv.staticElement?.declaration.source.contents.data}');
                continue;
              }
              addLintMessage(
                  reporter,
                  expression,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 6');

              FunctionBody body =
                  (functionInv.function as FunctionExpression).body;
              addLintMessage(
                  reporter,
                  expression,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 6.1');
              if (body is BlockFunctionBody) {
                addLintMessage(
                    reporter,
                    expression,
                    msgDebugMode
                        ? errors.ErrorSeverity.ERROR
                        : errors.ErrorSeverity.INFO,
                    'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 6.2');
                body.block.statements.forEach((Statement statement) {
                  addLintMessage(
                      reporter,
                      expression,
                      msgDebugMode
                          ? errors.ErrorSeverity.ERROR
                          : errors.ErrorSeverity.INFO,
                      'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 6.3');
                  if (statement is ReturnStatement) {
                    addLintMessage(
                        reporter,
                        expression,
                        msgDebugMode
                            ? errors.ErrorSeverity.ERROR
                            : errors.ErrorSeverity.INFO,
                        'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 6.4');
                    if (statement.expression != null) {
                      if (theTopLevelAncestorIdentifier != null) {
                        topLevelIdentifiersProducingExpressions[statement
                            .expression!
                            .unParenthesized] = theTopLevelAncestorIdentifier;
                      }
                      nextIterationExpressions
                          .add(statement.expression!.unParenthesized);
                    } else {
                      wasThereAnyEmptyReturnStatement = true;
                    }
                  }
                });
              } else if (body is ExpressionFunctionBody) {
                if (theTopLevelAncestorIdentifier != null) {
                  topLevelIdentifiersProducingExpressions[body.expression
                      .unParenthesized] = theTopLevelAncestorIdentifier;
                }
                nextIterationExpressions.add(body.expression.unParenthesized);
              } else if (body is EmptyFunctionBody) {
                wasThereAnyEmptyFunctionBody = true;
              }

              //int? id = functionInv.staticElement?.declaration.id;
              int? id = (functionInv.function as FunctionExpression)
                  .declaredElement
                  ?.id;
              addLintMessage(
                  reporter,
                  expression,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'getUltimateNonConditionalNorSwitchExpressions() iterationExpressions[i] is InvocationExpression == true : 7, id = $id, returnStatements[id] = ${returnStatements[id]}');
              var returnStatementList = returnStatements[id];
              if (returnStatementList == null) {
                addLintMessage(
                    reporter,
                    expression,
                    errors.ErrorSeverity.WARNING,
                    'getUltimateNonConditionalNorSwitchExpressions() functionInv; id is ${(functionInv.function as FunctionExpression).declaredElement?.id}, we are iteration through return expressions, in the return we don\'t have any ReturnStatement instances for this method. it is warning, but is it an error problem?');
              } else {
                for (int k = 0; k < returnStatementList.length; k++) {
                  if (returnStatementList[k].expression == null) {
                    addLintMessage(
                        reporter,
                        expression,
                        errors.ErrorSeverity.ERROR,
                        'getUltimateNonConditionalNorSwitchExpressions() functionInv; we are iteration through return expressions, in the return logically should never be a void return call like return () {}(); rather (){}();return;, there must be an expression; such a situation should never happen but for now null is accepted, that at least one return was so.');
                  }
                  if (returnStatementList[k].expression != null) {
                    if (theTopLevelAncestorIdentifier != null) {
                      topLevelIdentifiersProducingExpressions[
                          returnStatementList[k]
                              .expression!
                              .unParenthesized] = theTopLevelAncestorIdentifier;
                    }
                    nextIterationExpressions.add(
                        returnStatementList[k].expression!.unParenthesized);
                  } else {
                    wasThereAnyEmptyReturnStatement = true;
                  }
                }
              }
            }
          } else if (iterationExpressions[i] is BinaryExpression) {
            //topLevelIdentifiersProducingExpressions[assignmentExpression.unParenthesized]=iterationExpressions[i] as Identifier;
            Identifier? theTopLevelAncestorIdentifier =
                topLevelIdentifiersProducingExpressions[
                    iterationExpressions[i]];
            if (throwOnConditionalLikeOrFunctionOrPossibleIdentifierMultipleAssignmentExpressions) {
              throw Exception(
                  'getUltimateNonConditionalNorSwitchExpressions(), there is no need for this exception to be handled becuse it was originally to be used only by getUltimateConstLikeExpressions() method');
            }
            // WARNING! Make sure else is after this "is BinaryExpression" condition
            var subExpression = iterationExpressions[i] as BinaryExpression;
            if (subExpression.operator.toString() == '??') {
              if (theTopLevelAncestorIdentifier != null) {
                topLevelIdentifiersProducingExpressions[subExpression
                    .leftOperand
                    .unParenthesized] = theTopLevelAncestorIdentifier;
              }
              if (theTopLevelAncestorIdentifier != null) {
                topLevelIdentifiersProducingExpressions[subExpression
                    .rightOperand
                    .unParenthesized] = theTopLevelAncestorIdentifier;
              }
              nextIterationExpressions
                  .add(subExpression.leftOperand.unParenthesized);
              nextIterationExpressions
                  .add(subExpression.rightOperand.unParenthesized);
            } else {
              expressions.add(iterationExpressions[i].unParenthesized);
            }
            addLintMessage(reporter, expression, errors.ErrorSeverity.WARNING,
                'Binary expression what we have = ${subExpression.leftOperand.toSource()} # ${subExpression.leftOperand is Identifier}, ${subExpression.leftOperand is IntegerLiteral}, ${subExpression.rightOperand is Identifier} ${subExpression.rightOperand is IntegerLiteral}, ${subExpression.leftOperand.staticType}, ${subExpression.rightOperand.staticType} ${subExpression.rightOperand.staticType} ${subExpression.leftOperand.runtimeType} ${subExpression.operator.toString()}, ${subExpression.operator.stringValue}, ${subExpression.operator.value().toString()}, ${subExpression.operator.keyword?.name}, ${subExpression.leftOperand.runtimeType} ${subExpression.rightOperand.toString()}');
          } else {
            addLintMessage(reporter, expression, errors.ErrorSeverity.WARNING,
                'which type of current expression = ${iterationExpressions[i].runtimeType}');
            // now probably wrongly assume that this expression is a returned value (not switch/conditional/parenthesis), but we need to start somewhere
            expressions.add(iterationExpressions[i].unParenthesized);
          }
        }
        iterationExpressions = nextIterationExpressions;
      }
      return (
        expressions: expressions,
        topLevelIdentifiersProducingExpressions:
            topLevelIdentifiersProducingExpressions,
        wasThereAnyEmptyReturnStatement: wasThereAnyEmptyReturnStatement,
        wasThereAnyEmptyFunctionBody: wasThereAnyEmptyFunctionBody
      );
    } catch (e, stackTrace) {
      addLintMessage(reporter, expression, errors.ErrorSeverity.INFO,
          'Lint plugin exception: $e $stackTrace');
      return (
        expressions: [],
        topLevelIdentifiersProducingExpressions: null,
        wasThereAnyEmptyReturnStatement: false,
        wasThereAnyEmptyFunctionBody: false
      );
    }
  }

  bool getComparableValueDartObjectInstanceShared(
      ErrorReporter reporter,
      Map<dynamic, List<ReturnStatement>> returnStatements,
      Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId,
      Map<int, List<VariableDeclaration>> variableDeclarationsByElementId,
      DartObject? dartObject,
      Map<ComparableUltimateValue, Object?> valueMap,
      Expression? expression) {
    bool displayError = true;
    String msg = '';
    String mainName = '';
    Object? messageNode = expression ?? dartObject?.variable;
    if (messageNode != null) {
      addLintMessage(
          reporter,
          messageNode,
          msgDebugMode || displayError
              ? errors.ErrorSeverity.ERROR
              : errors.ErrorSeverity.INFO,
          'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() We\'ve entered another terrible method!');
    }
    if (expression is Identifier) {
      mainName = expression.name;
    } else {
      if (dartObject?.variable == null) {
        if (messageNode != null) {
          addLintMessage(reporter, messageNode, errors.ErrorSeverity.ERROR,
              'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() ERROR: unable to get name from dartObject, at this stage it is unexpected that the DartObject doesn\'t contain infor about name of the variable which is essential.');
        }
        addLintMessage(reporter, messageNode, errors.ErrorSeverity.ERROR,
            'getComparableValueFromExpressionOrDartObject() stage #T4 ERROR: probably object taken from annotation getField - dreamed of getting variable from it like from Identifier compure... DartObject. : dartObject = $dartObject, dartObject?.variable == ${dartObject?.variable}, dartObject?.type == ${dartObject?.type} , dartObject?.type?.element == ${dartObject?.type?.element}');
        if (dartObject != null) {
          valueMap[ComparableUltimateValue.dartObject] = dartObject;

          /// We assume that for the below conditions like dartObject.toBoolValue() must not be null
          if (dartObject.isNull) {
            valueMap[ComparableUltimateValue.simple] = null;
            return true;
          } else if (dartObject.type?.isDartCoreBool == true) {
            valueMap[ComparableUltimateValue.simple] = dartObject.toBoolValue();
            return true;
          } else if (dartObject.type?.isDartCoreInt == true) {
            valueMap[ComparableUltimateValue.simple] = dartObject.toIntValue();
            return true;
          } else if (dartObject.type?.isDartCoreDouble == true) {
            valueMap[ComparableUltimateValue.simple] =
                dartObject.toDoubleValue();
            return true;
          } else if (dartObject.type?.isDartCoreList == true) {
            valueMap[ComparableUltimateValue.simple] = dartObject.toListValue();
            return true;
          } else if (dartObject.type?.isDartCoreMap == true) {
            valueMap[ComparableUltimateValue.simple] = dartObject.toMapValue();
            return true;
          } else if (dartObject.type?.isDartCoreSet == true) {
            valueMap[ComparableUltimateValue.simple] = dartObject.toSetValue();
            return true;
          } else if (dartObject.type?.isDartCoreString == true) {
            valueMap[ComparableUltimateValue.simple] =
                dartObject.toStringValue();
            return true;
          } else if (dartObject.type?.isDartCoreFunction == true) {
            valueMap[ComparableUltimateValue.simple] =
                dartObject.toFunctionValue();
            return true;
          }
        }
        return false;
      } else {
        mainName = dartObject!.variable!.name;
      }
    }

    // includes initializer
    int assignmentExpressionsCounter = 0;
    // not else - a separate condition
    if (dartObject != null) {
      Expression? returnedExpression;
      //Element? declaration = expression.staticElement?.declaration;
      VariableElement? declaration = dartObject.variable?.declaration;
      bool declarationFound = false;
      if (messageNode != null) {
        // one declared variable with value but with no further assignments:
        // for the later - getter no getter versions if declared - how this behaves?
        // dartObject.variable?.id = 20439, == declaration.getter?.variable2?.id
        // FIXME: fixme? BUT ID DIDN'T CHECK (MAYBE NO NEED) declaration?.id supposedly also 20439
        // works: variableDeclarationsByElementId[declaration.getter?.variable2?.declaration.id]
        // works: variableDeclarationsByElementId[declaration.getter?.variable2?.id]
        // so should work:
        // works: assignmentExpressionsByElementId[declaration.getter?.variable2?.declaration.id]
        // works: assignmentExpressionsByElementId[declaration.getter?.variable2?.id]

        //addLintMessage(
        //    reporter,
        //    messageNode,
        //    msgDebugMode
        //        ? errors.ErrorSeverity.ERROR
        //        : errors.ErrorSeverity.INFO,
        //    '''getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(),
        //    dartObject.variable = ${dartObject.variable},
        //    dartObject.variable?.id = ${dartObject.variable?.id},
        //    declaration?.id = ${declaration?.id},
        //    declaration is VariableElement = ${declaration is VariableElement},
        //    declaration is PropertyInducingElement = ${declaration is PropertyInducingElement},
        //    declaration is FieldElement = ${declaration is FieldElement},
        //    declaration is FieldElement ? declaration.getter?.id : null = ${declaration is FieldElement ? declaration.getter?.id : null},
        //    declaration is FieldElement ? declaration.getter?.declaration.id : null = ${declaration is FieldElement ? declaration.getter?.declaration.id : null},
        //    declaration is FieldElement ? declaration.getter?.variable2?.id : null = ${declaration is FieldElement ? declaration.getter?.variable2?.id : null},
        //    declaration is FieldElement ? declaration.getter?.variable2?.declaration.id : null = ${declaration is FieldElement ? declaration.getter?.variable2?.declaration.id : null},
//
        //    declaration is FieldElement && declaration.getter !=null ? assignmentExpressionsByElementId[declaration.getter?.id] : null ${declaration is FieldElement && declaration.getter != null ? assignmentExpressionsByElementId[declaration.getter?.id] : null}                  ,
        //    declaration is FieldElement && declaration.getter !=null ? assignmentExpressionsByElementId[declaration.getter?.declaration.id] : null ${declaration is FieldElement && declaration.getter != null ? assignmentExpressionsByElementId[declaration.getter?.declaration.id] : null}                  ,
        //    declaration is FieldElement && declaration.getter?.variable2 != null ? assignmentExpressionsByElementId[declaration.getter?.variable2?.id] : null ${declaration is FieldElement && declaration.getter?.variable2 != null ? assignmentExpressionsByElementId[declaration.getter?.variable2?.id] : null}                  ,
        //    declaration is FieldElement && declaration.getter?.variable2 != null ? assignmentExpressionsByElementId[declaration.getter?.variable2?.declaration.id] : null ${declaration is FieldElement && declaration.getter?.variable2 != null ? assignmentExpressionsByElementId[declaration.getter?.variable2?.declaration.id] : null}                  ,
        //
        //    declaration is FieldElement && declaration.getter !=null ? variableDeclarationsByElementId[declaration.getter?.id] : null ${declaration is FieldElement && declaration.getter != null ? variableDeclarationsByElementId[declaration.getter?.id] : null}                  ,
        //    declaration is FieldElement && declaration.getter !=null ? variableDeclarationsByElementId[declaration.getter?.declaration.id] : null ${declaration is FieldElement && declaration.getter != null ? variableDeclarationsByElementId[declaration.getter?.declaration.id] : null}                  ,
        //    declaration is FieldElement && declaration.getter?.variable2 != null ? variableDeclarationsByElementId[declaration.getter?.variable2?.id] : null ${declaration is FieldElement && declaration.getter?.variable2 != null ? variableDeclarationsByElementId[declaration.getter?.variable2?.id] : null}                  ,
        //    declaration is FieldElement && declaration.getter?.variable2 != null ? variableDeclarationsByElementId[declaration.getter?.variable2?.declaration.id] : null ${declaration is FieldElement && declaration.getter?.variable2 != null ? variableDeclarationsByElementId[declaration.getter?.variable2?.declaration.id] : null}                  ,
        //
//
        //    declaration is TopLevelVariableElement = ${declaration is TopLevelVariableElement},
        //    declaration is VariableDeclaration = ${declaration is VariableDeclaration},
        //    declaration is FieldDeclaration = ${declaration is FieldDeclaration}
        //    dartObject.variable.runtimeType = ${dartObject.variable.runtimeType}''');
      }
      if (declaration != null) {
        //if (
        //
        //    /// FIXME: NEVER TRUE:
        //    declaration is FieldElement) {
        //isFinal, isConst
        declarationFound = true;
        //if (variableDeclaration.isFinal ||
        //    variableDeclaration.isConst) {
        final int? id = declaration is FieldElement
            ? declaration.getter?.variable2?.declaration.id
            : dartObject.variable?.id;
        //returnedExpression - also this could be used: variableDeclarationsByElementId[id]
        returnedExpression =
            variableDeclarationsByElementId[id]?.first.initializer;
        msg +=
            'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(), VariableDeclaration expression.name: ${mainName} FieldDeclaration - returned expression returnedExpression (can be null or Expression) - initializer has been found, expression = $returnedExpression';
        if (returnedExpression != null) {
          var ultimateExpressions =
              getUltimateNonConditionalNorSwitchExpressions(
                  reporter,
                  returnStatements,
                  variableDeclarationsByElementId,
                  assignmentExpressionsByElementId,
                  returnedExpression);
          assignmentExpressionsCounter +=
              ultimateExpressions.expressions.length;
          if (assignmentExpressionsCounter > 1) {
            if (messageNode != null) {
              addLintMessage(reporter, messageNode, errors.ErrorSeverity.ERROR,
                  'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(), VariableDeclaration ERROR #1: more than one expression extracted from Identifier() (any variable may have a declaration initializer expression and/or possibly many assignments) expression has been found. In this case a variable must have known ultimate value expression');
            }
            return false;
          } else if (ultimateExpressions.expressions.length == 1) {
            msg +=
                'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(), VariableDeclaration id = $id found at least one assignment expression assignmentExpressionsByElementId[id]';
            valueMap[ComparableUltimateValue.expression] =
                ultimateExpressions.expressions.first;
          }
        }
        if (assignmentExpressionsByElementId[id] != null &&
            assignmentExpressionsByElementId[id]!.isNotEmpty) {
          for (AssignmentExpression assignmentExpression
              in assignmentExpressionsByElementId[id]!) {
            var ultimateExpressions =
                getUltimateNonConditionalNorSwitchExpressions(
                    reporter,
                    returnStatements,
                    variableDeclarationsByElementId,
                    assignmentExpressionsByElementId,
                    assignmentExpression.rightHandSide);
            assignmentExpressionsCounter +=
                ultimateExpressions.expressions.length;
            if (assignmentExpressionsCounter > 1) {
              if (messageNode != null) {
                addLintMessage(
                    reporter,
                    messageNode,
                    errors.ErrorSeverity.ERROR,
                    'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(), VariableDeclaration ERROR #2: more than one expression extracted from Identifier() (any variable may have a declaration initializer expression and/or possibly many assignments) expression has been found. In this case a variable must have known ultimate value expression');
              }
              return false;
            } else if (ultimateExpressions.expressions.length == 1) {
              msg +=
                  'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(), VariableDeclaration id = $id found at least one assignment expression assignmentExpressionsByElementId[id]';
              valueMap[ComparableUltimateValue.expression] =
                  ultimateExpressions.expressions.first;
            }
          }
        } else {
          msg +=
              'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(), VariableDeclaration id = $id  couldn\'t find found at least one assignment expression assignmentExpressionsByElementId[id]';
        }
        //} else {
        //  msg +=
        //      'getComparableValueFromExpressionOrDartObject() case Identifier(),  VariableDeclaration expression can\'t be use because it is not final nor const';
        //}
//        }

        // (expression.staticElement.declaration as FieldDeclaration).fields.variables.first.initializer;
        // ((inv.argumentList.arguments.first.staticParameterElement?.metadata.first.element?.declaration as ClassMember) as FieldDeclaration).fields.variables.first.initializer;

        if (declarationFound == false) {
          if (messageNode != null) {
            addLintMessage(reporter, messageNode, errors.ErrorSeverity.ERROR,
                'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(),  ERROR: no declaration not found IT IS EXPECTED TO BE FOUND ALWAYS');
          }
        }
      } else {
        if (messageNode != null) {
          addLintMessage(reporter, messageNode, errors.ErrorSeverity.ERROR,
              'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(),  ########## ERROR: DECLARATION IS EXPECTED TO BE ALWAYS FOUND ##############');
        }
      }

      valueMap[ComparableUltimateValue.dartObject] = dartObject;

      /// We assume that for the below conditions like dartObject.toBoolValue() must not be null
      if (dartObject.isNull) {
        valueMap[ComparableUltimateValue.simple] = null;
      } else if (dartObject.type?.isDartCoreBool == true) {
        valueMap[ComparableUltimateValue.simple] = dartObject.toBoolValue();
      } else if (dartObject.type?.isDartCoreInt == true) {
        valueMap[ComparableUltimateValue.simple] = dartObject.toIntValue();
      } else if (dartObject.type?.isDartCoreDouble == true) {
        valueMap[ComparableUltimateValue.simple] = dartObject.toDoubleValue();
      } else if (dartObject.type?.isDartCoreList == true) {
        valueMap[ComparableUltimateValue.simple] = dartObject.toListValue();
      } else if (dartObject.type?.isDartCoreMap == true) {
        valueMap[ComparableUltimateValue.simple] = dartObject.toMapValue();
      } else if (dartObject.type?.isDartCoreSet == true) {
        valueMap[ComparableUltimateValue.simple] = dartObject.toSetValue();
      } else if (dartObject.type?.isDartCoreString == true) {
        valueMap[ComparableUltimateValue.simple] = dartObject.toStringValue();
      } else if (dartObject.type?.isDartCoreFunction == true) {
        valueMap[ComparableUltimateValue.simple] = dartObject.toFunctionValue();
      }
    }

    if (messageNode != null) {
      addLintMessage(
          reporter,
          messageNode,
          msgDebugMode || displayError
              ? errors.ErrorSeverity.ERROR
              : errors.ErrorSeverity.INFO,
          'getComparableValueFromExpressionOrDartObject() getComparableValueDartObjectInstanceShared() case Identifier(), possibly more to be printed in the getComparableValueDartObjectInstanceShared() body but the current msg = $msg');
    }
    return true;
  }

  // when isValueTakenFromLiteral == null means that a returned value is universal
  // isThisMap was added because literal has only SetOrMapLiteral(), true = is Map, false is Set, null - none of the both
  // if isValueTakenFromLiteral == false the returned value is DartObject with and as tested it can be compared with another DartObject (as i tested)
  // if isValueTakenFromLiteral == true the value is taken from Literal with not tested chance to compare with the same (List, Map, instance) object that is also taken from litera.
  // like 0.5 double value taken from literal is computed to something normal - double type value not DartCoreDouble or something like that.
  // but for record or List you can compare two values (assuming so - to test yet) only when bothw compared values are taken from Identifier or a ListLiteral or RecordLiteral
  ({
    bool valueHasBeenFound,
    Map<ComparableUltimateValue, Object?>? value,
//      UltimateValueType? ultimateValueType
  }) getComparableValueFromExpressionOrDartObject(
      ErrorReporter reporter,
      Map<dynamic, List<ReturnStatement>> returnStatements,
      Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId,
      Map<int, List<VariableDeclaration>> variableDeclarationsByElementId,
      Expression? expression,
      [DartObject? dartObjectParam,
      Object? msgNode]) {
    bool displayError = true;
    DartObject? dartObject = dartObjectParam;
    if (dartObject == null) {
      if (expression != null) {
        addLintMessage(
            reporter,
            expression,
            msgDebugMode || displayError
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'getComparableValueFromExpressionOrDartObject(), expression is not null.');
        switch (expression) {
          // FIXME: not fixme - to turn your attention: an expression may be conditional binary, f.e. abc ?? cde, abc + cde - this by nature doesn't produce 100% result - is too difficult now to implement calculation maybe later with dart_eval.
          // it shoudn't be identifier as a declaration and optional further assignemts are broke down into ultimate expressions
          case Identifier():
            // here becaue it says CommentReferableExpression covers this, but actually SimpleIdentifier is of CommentReferableExpression.
            // WARNING: SEE THERE IS RecordLiteral()
            // for this you may have to finde expression for this identifier that produces RecordLiteral()
            // and assuming that both instances are comparable as to if they are equal you may use them
            // FIXME: FIXME:
            // the identifier maybe const or have constant like assigned value after declaration.
            // let's focus on const
            // maybe if we find the assignment we can get the rightHand or similar exprssion
            // if we have expression that is RecordLiteral, Listliteral... no what if there are references to some things literals.
            // basically uncomparable this way :(
            // Conclusion, possibly the only reliable way to compare objects is via
            // DartObject way.

            String msg = '';
            if (expression.staticElement is VariableElement) {
              (expression.staticElement as VariableElement).declaration;
              var elem = (expression.staticElement as VariableElement);
              msg +=
                  'getComparableValueFromExpressionOrDartObject() case Identifier(),  VariableElement elema.id = ${elem.id}, elema.id = ${elem.nonSynthetic.id}, elem.context.declaredVariables = ${elem.context.declaredVariables}, elem.nonSynthetic.context.declaredVariables = ${elem.nonSynthetic.context.declaredVariables}';

              dartObject = (expression.staticElement as VariableElement)
                  .computeConstantValue();
            }

            if (expression.staticElement is PropertyAccessorElement) {
              var elem = (expression.staticElement as PropertyAccessorElement);
              var variable2 = elem.variable2;
              dartObject = variable2?.computeConstantValue();
              var variable2_variety = elem.variable2?.getter?.variable2;
              var dartObject_variety = variable2?.computeConstantValue();
              dartObject = dartObject_variety;
              msg +=
                  'getComparableValueFromExpressionOrDartObject() case Identifier(),  VariableElement elema.id = ${elem.id}, elema.id = ${elem.nonSynthetic.id}, elem.context.declaredVariables = ${elem.context.declaredVariables}, elem.nonSynthetic.context.declaredVariables = ${elem.nonSynthetic.context.declaredVariables}';

              msg +=
                  'getComparableValueFromExpressionOrDartObject() case Identifier(),  PropertyAccessorElement variable2=${variable2} getter = ${variable2?.getter}, variable2?.getter?.hasImplicitReturnType = ${variable2?.getter?.hasImplicitReturnType}, dartObject?.type = ${dartObject?.type} dartObject?.type?.isDartCoreInt = ${dartObject?.type?.isDartCoreInt} ${dartObject} ';
              msg +=
                  'getComparableValueFromExpressionOrDartObject() case Identifier(),  PropertyAccessorElement variable2_variety=${variable2_variety} getter = ${variable2_variety?.getter}, variable2_variety?.getter?.hasImplicitReturnType = ${variable2_variety?.getter?.hasImplicitReturnType}, dartObject_variety?.type = ${dartObject_variety?.type} dartObject_variety?.type?.isDartCoreInt = ${dartObject_variety?.type?.isDartCoreInt} ${dartObject_variety} ';
              //if (elem.variable2.getter.hasImplicitReturnType) {
              //  //elem.variable2.
              //}
            }

            //PropertyAccessorElementImpl_ImplicitGetter

            Map<ComparableUltimateValue, Object?> valueMap = {};
            if (getComparableValueDartObjectInstanceShared(
                    reporter,
                    returnStatements,
                    assignmentExpressionsByElementId,
                    variableDeclarationsByElementId,
                    dartObject,
                    valueMap,
                    expression) ==
                false) {
              return (
                valueHasBeenFound: false,
                value: null,
              );
            }

            ({
              bool valueHasBeenFound,
              Map<ComparableUltimateValue, Object?>? value,
              // UltimateValueType? ultimateValueType
            }) record;
            if (valueMap.isNotEmpty) {
              msg +=
                  'getComparableValueFromExpressionOrDartObject() case Identifier(), return value has been found';
              record = (
                valueHasBeenFound: true,
                value: valueMap,
              );
            } else {
              msg +=
                  'getComparableValueFromExpressionOrDartObject() case Identifier(), return value hasn\'t been found';
              record = (
                valueHasBeenFound: false,
                value: null,
              );
            }

            addLintMessage(
                reporter,
                expression,
                displayError
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                'getComparableValueFromExpressionOrDartObject() case Identifier(),  msg = $msg, it is Identifier(). dartObject.type?.isDartCoreInt = ${dartObject?.type?.isDartCoreInt}, dartObject = ${dartObject}, ${expression.staticElement is VariableElement}, ${expression.runtimeType}, ${expression.staticElement?.runtimeType}, ${expression.staticElement}');

            return record;

          // will the following ever be used?
          //case CommentReferableExpression():
          //  // [ConstructorReference] | [FunctionReference] | [PrefixedIdentifier] | [PropertyAccess] | [SimpleIdentifier] | [TypeLiteral]
          //  // and possibly more
          //  switch (expression) {
          //    case ConstructorReference(): // not constructor invokation
          //      break;
          //    case PropertyAccess():
          //      break;
          //  }
          case IntegerLiteral():
            // it sees it is IntegerLiteral but .value might be null - i don't understand it;
            // it seems inconsistent with its corresponding similar DoubleLiteral which can't be null
            if (expression.value != null) {
              return (
                valueHasBeenFound: true,
                value: {ComparableUltimateValue.simple: expression.value!},
                //ultimateValueType: null
              );
            }
            break;
          case NullLiteral():
            // it sees it is IntegerLiteral but .value might be null - i don't understand it;
            return (
              valueHasBeenFound: true,
              value: {ComparableUltimateValue.simple: null},
              //ultimateValueType: null
            );
          case DoubleLiteral():
            return (
              valueHasBeenFound: true,
              value: {ComparableUltimateValue.simple: expression.value},
              //ultimateValueType: null
            );
          //case RecordLiteral():
          //  // we don't have a value like for Integer literal but have probably difficult .fields with expression of more or less easy computable values.
          //  // but if it fails there is NO IN "case Identifier()" toRecordValue() , BUT .variable is computable and objects can be compared with this.
          //  // it sees it is IntegerLiteral but .value might be null - i don't understand it;
          //
          //  // return (valueHasBeenFound: true, value: null);
          //  return (
          //    valueHasBeenFound: true,
          //    value: {ComparableUltimateValue.expression: expression},
          //    //ultimateValueType: null
          //  );
          case StringLiteral():
            switch (expression) {
              case SimpleStringLiteral():
                if (expression.stringValue != null) {
                  return (
                    valueHasBeenFound: true,
                    value: {
                      ComparableUltimateValue.simple: expression.stringValue
                    },
                    //ultimateValueType: null
                  );
                }
                break;
              case StringInterpolation(): // Difficult to handle - for the later.
                return (
                  valueHasBeenFound: false,
                  value: null,
                );
                break;
              case _: // AdjacentStrings() ignored
                return (
                  valueHasBeenFound: false,
                  value: null,
                );
                break;
            }
            break;
          case RecordLiteral():
            return (
              valueHasBeenFound: true,
              value: {ComparableUltimateValue.expression: expression},
              //ultimateValueType: null
            );
          case ListLiteral():
            return (
              valueHasBeenFound: true,
              value: {ComparableUltimateValue.expression: expression},
              //ultimateValueType: null
            );
          case SetOrMapLiteral():
            return (
              valueHasBeenFound: true,
              value: {ComparableUltimateValue.expression: expression},
              //ultimateValueType: expression.isMap ? UltimateValueType.map : UltimateValueType.set
            );
          //case InvocationExpression():
          //  switch (expression) {
          //    case MethodInvocation():
          //      return (
          //        valueHasBeenFound: true,
          //        value: {ComparableUltimateValue.expression: expression},
          //        //ultimateValueType: expression.isMap ? UltimateValueType.map : UltimateValueType.set
          //      );
          //    case FunctionExpressionInvocation():
          //      return (
          //        valueHasBeenFound: true,
          //        value: {ComparableUltimateValue.expression: expression},
          //        //ultimateValueType: expression.isMap ? UltimateValueType.map : UltimateValueType.set
          //      );
          //  }
          //  break;
          case InstanceCreationExpression():
            // doesnt get you a DartObject but
            // having DartObject (now don't remember how here) you can
            // ExecutableElement? .toFunctionValue and this as docs says:
            // maybe null means function was not const or constructor too.
            // or even if it wasn't const was not computable or something
            // !!! can be: ConstructorElement or FunctionElement or MethodElement ...
            // possibly two such FunctionElement could be compared
            // 1. abc(1) == abc(1) two executable elements produced from this might be equal (or it doesn't work this way)
            // 2. abc(1) != abc(1) might not.
            //
            // We have to compare it as is in the method comparing
            return (
              valueHasBeenFound: true,
              value: {ComparableUltimateValue.expression: expression},
            );
          default:
            addLintMessage(reporter, expression, errors.ErrorSeverity.INFO,
                'getComparableValueFromExpressionOrDartObject() an expression is not handled by the switch(expression) statement (this is default: clause) message.');

            return (
              valueHasBeenFound: false,
              value: null,
            );
        }
      }
    } else {
      String msg = '';
      Map<ComparableUltimateValue, Object?> valueMap = {};
      addLintMessage(
          reporter,
          dartObject.variable ?? msgNode,
          msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
          'getComparableValueFromExpressionOrDartObject()  dartObject supplied, stage #T1 dartObject = $dartObject, dartObject?.variable == ${dartObject?.variable}, dartObject?.type == ${dartObject?.type} , dartObject?.type?.element == ${dartObject?.type?.element}');
      if (getComparableValueDartObjectInstanceShared(
              reporter,
              returnStatements,
              assignmentExpressionsByElementId,
              variableDeclarationsByElementId,
              dartObject,
              valueMap,
              null) ==
          false) {
        addLintMessage(
            reporter,
            dartObject.variable ?? msgNode,
            msgDebugMode
                ? errors.ErrorSeverity.ERROR
                : errors.ErrorSeverity.INFO,
            'getComparableValueFromExpressionOrDartObject()  dartObject supplied, stage #T2');
        valueMap[ComparableUltimateValue.dartObject] = dartObject;
        ({
          bool valueHasBeenFound,
          Map<ComparableUltimateValue, Object?>? value,
          // UltimateValueType? ultimateValueType
        }) record = (
          valueHasBeenFound: true,
          value: valueMap,
        );

        return record;
      } else {
        ({
          bool valueHasBeenFound,
          Map<ComparableUltimateValue, Object?>? value,
          // UltimateValueType? ultimateValueType
        }) record;
        if (valueMap.isNotEmpty) {
          msg +=
              'getComparableValueFromExpressionOrDartObject() dartObject supplied, return value has been found';
          record = (
            valueHasBeenFound: true,
            value: valueMap,
          );
        } else {
          msg +=
              'getComparableValueFromExpressionOrDartObject() dartObject supplied, return value hasn\'t been found';
          /*
          Previously:
          record = (
            valueHasBeenFound: false,
            value: null,
          );
          
           */

          valueMap[ComparableUltimateValue.dartObject] = dartObject;
          record = (
            valueHasBeenFound: true,
            value: valueMap,
          );
        }
        if (dartObject.variable != null || msgNode != null) {
          addLintMessage(
              reporter,
              dartObject.variable ?? msgNode,
              msgDebugMode
                  ? errors.ErrorSeverity.ERROR
                  : errors.ErrorSeverity.INFO,
              'getComparableValueFromExpressionOrDartObject()  dartObject supplied,  msg = $msg, . dartObject.type?.isDartCoreInt = ${dartObject?.type?.isDartCoreInt}, dartObject = ${dartObject}');
        }
        return record;
      }
    }
    addLintMessage(
        reporter,
        expression ?? dartObject?.variable ?? msgNode,
        msgDebugMode ? errors.ErrorSeverity.ERROR : errors.ErrorSeverity.INFO,
        'getComparableValueFromExpressionOrDartObject() getComparableValueFromExpressionOrDartObject()  dartObject supplied, stage #T3');

    return (
      valueHasBeenFound: false,
      value: null,
    );
  }

  addLintMessage(ErrorReporter reporter, Object? node,
      errors.ErrorSeverity errorSeverity, String message) {
    if (node == null ||
        (displayErrorsOnly && errorSeverity != errors.ErrorSeverity.ERROR))
      return;
    try {
      if (node is Expression || node is AstNode) {
        reporter.atNode(
            node is Expression
                ? node as Expression
                : node as AstNode /*.parent!*/,
            LintCode(
              name: 'anno_types_warning',
              problemMessage: 'annotypes $message',
              errorSeverity: errorSeverity,
            ));
      } else if (node is Element) {
        reporter.atElement(
            node /*.parent!*/,
            LintCode(
              name: 'anno_types_warning',
              problemMessage: 'annotypes $message',
              errorSeverity: errorSeverity,
            ));
      }
    } catch (e) {}
  }

  @override
  void run(
    CustomLintResolver resolver,
    ErrorReporter reporter,
    CustomLintContext context,
  ) {
    /// WARNING! Based on the preliminary knowledge that parent node
    /// key is function or [MethodDeclaration] method declaration id;
    /// is always a [FunctionDeclaration] or [MethodDeclaration] - both are not extending or implementing each other.
    /// So because of this FunctionBody value in the key=>value pari is much better than a ...Declaration
    Map<dynamic, List<ReturnStatement>> returnStatements = {};
    Map<int, List<AssignmentExpression>> assignmentExpressionsByElementId = {};
    Map<int, List<VariableDeclaration>> variableDeclarationsByElementId = {};

    List<MethodDeclaration> methodDeclarations = [];
    Map<FunctionBody, MethodDeclaration> methodBodies = {};
    Set<bool> whatIsCalledFirst = {};

    /// warning: keep it compatible with checkingReturnTypesAndValues()
    /// returns null
    /// On error places lint error
    /// 1. when expression is in $N(expression) instance. so isNullableValue == true, but the to-be-returned final expression is not an Identifier(), because only Identifiers can have a type like int? not just int like the rest of sorts of expressions. conditions were not met, like $N(notAnIdentifierExpression)
    /// 2. When expression is Identifer but has type declaration not nullable - f.e int instead of int?
    ({Expression expression, bool isMutableValue})?
        getExpressionWithCustomComparisonRequirements(
            Expression expression, dynamic msgNode) {
      if (expression is! InstanceCreationExpression) {
        return (expression: expression, isMutableValue: false);
      } else {
        Expression finalExpression = expression;
        bool isMutableValue = false;
        bool isNullableValue = false;
        while (true) {
          if (finalExpression is InstanceCreationExpression) {
            switch (finalExpression.staticType?.getDisplayString()) {
              case "\$M":
                isMutableValue = true;
                finalExpression = expression.argumentList.arguments.first;
                continue;
              case "\$N":
                isNullableValue = true;
                finalExpression = expression.argumentList.arguments.first;
                continue;
            }
          }

          if (isNullableValue) {
            if (finalExpression is! Identifier) {
              addLintMessage(reporter, msgNode, errors.ErrorSeverity.ERROR,
                  'getExpressionWithCustomComparisonRequirements (like checkingReturnTypesAndValues() part) Error: Current expression was in the \$N(expression) so it must be Identifier() instance (int? abc = 10 - abc is Identifier() instance) with declared type that is nullable f.e. int? not int, List? not List');
              return null;
            } else {
              addLintMessage(
                  reporter,
                  msgNode,
                  msgDebugMode
                      ? errors.ErrorSeverity.ERROR
                      : errors.ErrorSeverity.INFO,
                  'getExpressionWithCustomComparisonRequirements (like checkingReturnTypesAndValues() part) isNullableValue == true hence Some data: (currentFieldExpression as Identifier).staticType?.nullabilitySuffix == ${(finalExpression as Identifier).staticType?.nullabilitySuffix} finalExpression.staticType == ${finalExpression?.staticType}');
              // FIXME: i expect this to contain info about nullabilitySuffix
              // if not you have to go to the declaration variable and get info about the type - left hand or writeElement dont remember now
              if ((finalExpression as Identifier)
                      .staticType
                      ?.nullabilitySuffix !=
                  NullabilitySuffix.question) {
                addLintMessage(reporter, msgNode, errors.ErrorSeverity.ERROR,
                    'getExpressionWithCustomComparisonRequirements (like checkingReturnTypesAndValues() part): Current expression was in the \$N(expression) and is Identifier() instance but it was not defined with a nullable type (int? abc = 10 - abc is Identifier() instance) with declared type that is nullable f.e. int? not int, List? not List. WARNING! Read doc // info above the place this message was defined, info on how to get the nullability info in different way if this was incorrect');
                return null;
              } else {}
            }
          }

          return (expression: finalExpression, isMutableValue: isMutableValue);
        }
      }
    }

    ({
      List<Expression> expressions,
      Expando<Identifier> topLevelIdentifiersProducingExpressions,
      bool wasThereAnyEmptyReturnStatement,
      bool wasThereAnyEmptyFunctionBody
    }) getAllExpressionsInfoFromFunctionBody(FunctionBody body,
        [Expando<Identifier>?
            topLevelIdentifiersProducingExpressionsSupplied]) {
      bool wasThereAnyEmptyReturnStatement = false;
      bool wasThereAnyEmptyFunctionBody = false;
      List<Expression> expressions = [];
      Expando<Identifier> topLevelIdentifiersProducingExpressions =
          topLevelIdentifiersProducingExpressionsSupplied ??
              Expando<Identifier>();
      if (body is BlockFunctionBody) {
        // DOESN'T WORK! DONE DIFFERENTLY
        // THE PROBLEM WAS THAT THE RETURN STATEMENTS MUST BE IMMEDIATE CHILDREN
        // NOT SOMETHING IN NESTED STUFF
        //body.block.statements.forEach((Statement statement) {
        //  if (statement is ReturnStatement) {
        //    if (statement.expression != null) {
        //      expressions.addAll(getUltimateNonConditionalNorSwitchExpressions(
        //              statement.expression!)
        //          .expressions);
        //    } else {
        //      wasThereAnyEmptyReturnStatement = true;
        //    }
        //  }
        //});
        if (returnStatements[body.parent] != null) {
          for (ReturnStatement returnStatement
              in returnStatements[body.parent]!) {
            if (returnStatement.expression != null) {
              expressions.addAll(getUltimateNonConditionalNorSwitchExpressions(
                      reporter,
                      returnStatements,
                      variableDeclarationsByElementId,
                      assignmentExpressionsByElementId,
                      returnStatement.expression!,
                      topLevelIdentifiersProducingExpressions)
                  .expressions);
            } else {
              wasThereAnyEmptyReturnStatement = true;
            }
          }
        }
      } else if (body is ExpressionFunctionBody) {
        expressions = getUltimateNonConditionalNorSwitchExpressions(
                reporter,
                returnStatements,
                variableDeclarationsByElementId,
                assignmentExpressionsByElementId,
                body.expression,
                topLevelIdentifiersProducingExpressions)
            .expressions;
      } else if (body is EmptyFunctionBody) {
        wasThereAnyEmptyFunctionBody = true;
      }
      return (
        expressions: expressions,
        topLevelIdentifiersProducingExpressions:
            topLevelIdentifiersProducingExpressions,
        wasThereAnyEmptyReturnStatement: wasThereAnyEmptyReturnStatement,
        wasThereAnyEmptyFunctionBody: wasThereAnyEmptyFunctionBody
      );
    }

    /// Any funtion like declaration has //[BlockFunctionBody] | [EmptyFunctionBody] | [ExpressionFunctionBody] | [NativeFunctionBody]
    /// this handles all except BlockFunctionBody, BlockFunctionBody has ReturnStatements the rest no.
    /// this is called form constext.registry.addMethodDeclaration it is handling all method declaration that have no [FunctionBlockBody] but the rest like empty, or expression
    /// Compare with handlingMethodDeclarationForFunctionBlockBodyReturnStatement which is for the rest of situations.
    handlingMethodDeclarationForNonFunctionBlockBody(
        MethodDeclaration methodDeclaration) {}

    /// Any funtion like declaration has //[BlockFunctionBody] | [EmptyFunctionBody] | [ExpressionFunctionBody] | [NativeFunctionBody]
    /// this handles only BlockFunctionBody with it's ReturnStatements
    /// this is not called form constext.registry.addMethodDeclaration but is called from addReturnStatement
    /// Compare with handlingMethodDeclarationForNonFunctionBlockBody which is for the rest of situations.
    handlingFunctionLikeDeclaration(dynamic declaration) {
      FunctionBody body;
      if (declaration is MethodDeclaration) {
        body = declaration.body;
      } else if (declaration is FunctionDeclaration) {
        body = declaration.functionExpression.body;
      } else if (declaration is FunctionExpression) {
        body = declaration.body;
      } else {
        // because the declaration param is dynamic we need to inform, and throw - never should happen in production so it is of diagnostic nature during initial steges of development
        String message =
            'handlingFunctionLikeDeclaration error: declaration param is not of the required function-like types because the declaration param is dynamic we need to inform, and throw - never should happen in production so it is of diagnostic nature during initial steges of development';
        addLintMessage(
            reporter, declaration, errors.ErrorSeverity.ERROR, message);
        throw Exception(message);
      }

      try {
        final (
          :expressions,
          :topLevelIdentifiersProducingExpressions,
          :wasThereAnyEmptyReturnStatement,
          :wasThereAnyEmptyFunctionBody
        ) = getAllExpressionsInfoFromFunctionBody(body);

        addLintMessage(reporter, declaration, errors.ErrorSeverity.WARNING,
            'handlingFunctionLikeDeclaration: wasThereAnyEmptyReturnStatement = $wasThereAnyEmptyReturnStatement, wasThereAnyEmptyFunctionBody = $wasThereAnyEmptyFunctionBody, expressions.length ${expressions.length}, expressions: ${expressions}');
        if (declaration is MethodDeclaration) {
          addLintMessage(reporter, declaration, errors.ErrorSeverity.WARNING,
              'handlingFunctionLikeDeclaration: calling checkingReturnTypesAndValues WARNING WARNING - PROBABLY FunctionDeclaration could be used as param for the method, but now focusing on MethodDeclaration. At the same time FunctionExpression is not allowed here expressions.length=${expressions.length}');
          try {
            bool? callingResult = checkingReturnTypesAndValues(
                reporter,
                returnStatements,
                assignmentExpressionsByElementId,
                variableDeclarationsByElementId,
                declaration,
                expressions,
                topLevelIdentifiersProducingExpressions);
            addLintMessage(
                reporter,
                declaration,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                'handlingFunctionLikeDeclaration: info: The first top level checkingReturnTypesAndValues call with the following result bool?: $callingResult');
          } catch (e, stackTrace) {
            addLintMessage(reporter, declaration, errors.ErrorSeverity.ERROR,
                'handlingFunctionLikeDeclaration: error: e = $e, stackTrace = $stackTrace');
          }
        } else {
          addLintMessage(reporter, declaration, errors.ErrorSeverity.WARNING,
              'handlingFunctionLikeDeclaration: NOT calling checkingReturnTypesAndValues');
        }
      } catch (e, stackTrace) {
        addLintMessage(reporter, declaration, errors.ErrorSeverity.WARNING,
            'handlingFunctionLikeDeclaration: CATCHED ERROR: e = $e, stackTrace = $stackTrace');
      }
      return;

      //whatIsCalledFirst.add(false);
      //methodDeclarations.add(methodDeclaration);
      //try {
      //  methodBodies[methodDeclaration.body] = methodDeclaration;
      //  //BlockFunctionBody] | [EmptyFunctionBody] | [ExpressionFunctionBody] | [NativeFunctionBody
      //  if (methodDeclaration.body is ExpressionFunctionBody) {
      //    var expression =
      //        (methodDeclaration.body as ExpressionFunctionBody).expression;
      //    // condition ? int : double; == num , condition ? String : double; Object
      //    ParenthesizedExpression; // .expression;
      //    ConditionalExpression; // probably including version "??"" and with .thenExpression, .elseExpression
      //    SwitchExpression; // .cases which are NodeList<SwitchExpressionCase> .expression for a case;
      //    addLintMessage(reporter,
      //        expression,
      //        errors.ErrorSeverity.WARNING,
      //        'addMethodDeclaration: whatIsCalledFirst = $whatIsCalledFirst , This is ExpressionFunctionBody expression runtimeType = ${expression.runtimeType} expression.type = ${expression.staticType} ${getUltimateNonConditionalNorSwitchExpressions(
      //          expression,
      //        ).expressions.length}');
      //
      //    NodeList<FormalParameter>? parameters =
      //        methodDeclaration.parameters?.parameters;
      //    if (parameters != null) {
      //      for (int i = 0; i < parameters.length; i++) {
      //        FormalParameterList;
      //        FormalParameter;
      //        NormalFormalParameter; // required
      //        DefaultFormalParameter; // having defaultvalue so not required [Expression]? get defaultValue;
      //        if (parameters[i] is DefaultFormalParameter) {
      //          var param = parameters[i] as DefaultFormalParameter;
      //          addLintMessage(reporter,param, errors.ErrorSeverity.WARNING,
      //              'addMethodDeclaration: This is parameter defaultValue, i: $i expression = ${param.defaultValue?.toSource()}, number of elements extracted: ${param.defaultValue != null ? getUltimateNonConditionalNorSwitchExpressions(param.defaultValue!).expressions.length : '... no element? Really? At least one should be.'}');
      //        }
      //      }
      //    }
      //  }
      //} catch (e, stackTrace) {
      //  addLintMessage(reporter,methodDeclaration, errors.ErrorSeverity.INFO,
      //      'Lint plugin exception: $e $stackTrace');
      //}
    }

    context.registry
        .addMethodDeclaration(handlingMethodDeclarationForNonFunctionBlockBody);

    /// Any funtion like declaration has //[BlockFunctionBody] | [EmptyFunctionBody] | [ExpressionFunctionBody] | [NativeFunctionBody]
    /// this handles all except BlockFunctionBody, BlockFunctionBody has ReturnStatements the rest no.
    /// this is called form constext.registry.addMethodDeclaration it is handling all method declaration that have no [FunctionBlockBody] but the rest like empty, or expression
    /// Compare with handlingMethodDeclarationForFunctionBlockBodyReturnStatement which is for the rest of situations.
    handlingFunctionExpressionForNonFunctionBlockBody(
        FunctionExpression functionExpression) {}

    /// Any funtion like declaration has //[BlockFunctionBody] | [EmptyFunctionBody] | [ExpressionFunctionBody] | [NativeFunctionBody]
    /// this handles only BlockFunctionBody with it's ReturnStatements
    /// this is not called form constext.registry.addMethodDeclaration but is called from addReturnStatement
    /// Compare with handlingMethodDeclarationForNonFunctionBlockBody which is for the rest of situations.
    handlingFunctionExpressionForFunctionBlockBodyReturnStatement(
        FunctionExpression functionExpression) {
      final (
        :expressions,
        :topLevelIdentifiersProducingExpressions,
        :wasThereAnyEmptyReturnStatement,
        :wasThereAnyEmptyFunctionBody
      ) = getAllExpressionsInfoFromFunctionBody(functionExpression.body);

      addLintMessage(reporter, functionExpression, errors.ErrorSeverity.WARNING,
          'handlingFunctionExpressionForFunctionBlockBodyReturnStatement: wasThereAnyEmptyReturnStatement = $wasThereAnyEmptyReturnStatement, wasThereAnyEmptyFunctionBody = $wasThereAnyEmptyFunctionBody, expressions.length ${expressions.length}, expressions: ${expressions}, topLevelIdentifiersProducingExpressions == ${topLevelIdentifiersProducingExpressions}');
      return;
    }

    context.registry.addFunctionExpression(
        handlingFunctionExpressionForNonFunctionBlockBody);

    handleReturnStatement(ReturnStatement returnStatement) {
      whatIsCalledFirst.add(true);
      AstNode? parentNode = returnStatement.parent;
      addLintMessage(reporter, returnStatement, errors.ErrorSeverity.INFO,
          'Return statement. Entered the method.');
      BlockFunctionBody;
      EmptyFunctionBody;
      NativeFunctionBody; // ignoring now, we want to be cross-platform for now
      ExpressionFunctionBody;
      // function, clause, method declarations:
      // .parent leads as (should) to:
      MethodDeclaration; // not the same or is as FunctionDeclaration, FunctionExpression;
      FunctionDeclaration; // local or top level, not the same or is as MethodDeclaration, FunctionExpression;
      // [!!!! EDIT: we have three of them FunctionExpression is this with no function/method name]
      /* expression gets you */ FunctionExpression; // and this gets you known .parameters
      // WARNING It might be that for clauses you get eighter FunctionDeclaration or FunctionExpression;
      // LOGICALLY SHLOULD BE FunctionDeclaration;
      // Also the following invokation classes as you see occur not in the third form FunctionExpression
      FunctionExpression; // equivalent of above declarations and not implemening MethodDeclaration, FunctionDeclaration;
      InvocationExpression; // The invocation of a function or method.
      // !!!!!! context.registry.addInvocationExpression();
      // !!! This will !!! either be a [FunctionExpressionInvocation] or a [MethodInvocation].
      /* one */ FunctionExpressionInvocation;
      /* two */ MethodInvocation;

      while (parentNode != null) {
        if (parentNode is FunctionBody) {
          int? id;
          if (parentNode.parent is MethodDeclaration) {
            id = (parentNode.parent as MethodDeclaration)
                .declaredElement
                ?.declaration
                .id;

            addLintMessage(
                reporter,
                returnStatement,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '.addReturnStatement parentNode is MethodDeclaration, id = $id');
          } else if (parentNode.parent is FunctionExpression) {
            id = (parentNode.parent as FunctionExpression).declaredElement?.id;
            addLintMessage(
                reporter,
                returnStatement,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '.addReturnStatement parentNode is FunctionExpression, id = $id');
          } else if (parentNode.parent is FunctionDeclaration) {
            id = (parentNode.parent as FunctionDeclaration)
                .declaredElement
                ?.declaration
                .id;
            addLintMessage(
                reporter,
                returnStatement,
                msgDebugMode
                    ? errors.ErrorSeverity.ERROR
                    : errors.ErrorSeverity.INFO,
                '.addReturnStatement parentNode is FunctionDeclaration, id = $id');
          }
          if (id == null) {
            addLintMessage(
                reporter,
                returnStatement,
                errors.ErrorSeverity.ERROR,
                '.addReturnStatement We never expect id == null');
            break;
          }

          /// below not needed probably
          if (returnStatements[id] == null) {
            returnStatements[id] = [];
            returnStatements[parentNode.parent] = [];
          }
          returnStatements[id]!.add(returnStatement);
          returnStatements[parentNode.parent]!.add(returnStatement);
          if (parentNode is ExpressionFunctionBody) {
            var expression = parentNode.expression;
            addLintMessage(
                reporter,
                returnStatement,
                errors.ErrorSeverity.WARNING,
                'This is ExpressionFunctionBody expression.type = ${expression.staticType}');
          }

          addLintMessage(reporter, returnStatement, errors.ErrorSeverity.INFO,
              'We\'ve found the method declaration for this return statement. is MethodDeclaration ${parentNode.parent is MethodDeclaration}, is FunctionDeclaration ${parentNode.parent is FunctionDeclaration}, current returnStatement object for this id returnStatements[id] = ${returnStatements[id]}');
          return;
        }
        parentNode = parentNode.parent;
      }
    }

    context.registry.addReturnStatement(handleReturnStatement);

    // [FunctionExpressionInvocation]: "Invocations of methods and other forms of functions are represented by MethodInvocation nodes."
    // so method is to be also for normal declared functions so it would be inconsistent with existing three not two
    // addMethodDeclaration addFunctionDeclaration addFunctionExpression
    context.registry
        .addFunctionExpressionInvocation((FunctionExpressionInvocation inv) {});

    // See the addMethodInvocation description above
    context.registry.addMethodInvocation((MethodInvocation inv) {
      return;
      inv.argumentList.arguments.first.staticParameterElement
          ?.computeConstantValue();
      // FIXME: not fixme just to grab your (mine - for me but different people can learn from it) attention.
      // TO SUM UP;
      // can work with arg that is simple literals like arg is DoubleLiteral
      // double, int, String, but it is SimpleStringLiteral not StringInterpolation
      // ====================
      // FIXME: after implementing all the rest i could return to StringInterpolation as i understand the calculation
      // of the expressions better. Cannot 100% calculate method/function or function expression invokaiton
      // ====================
      // FIXME: like with function like,
      // DartObject .toFunctionValue returns ExecutableElement? - not executed but description
      // Also
      // var functionInv = someobject as FunctionExpressionInvocation;
      // functionInv.staticElement; is also ExecutableElement?
      // it might be that it is not null when the result was computed (or no)
      // Comparing two instances of ExecutableElement might be with the following rule.
      // suggest it might be sort of the result so abc(1) == abc(1) but abc(1) != abc(2) - mean not params but RESULT of this might be comparable like other.
      // ====================
      // you might try (read for however), ${arg.name}, ${arg.staticElement?.id} ${arg.staticElement?.declaration}
      // This must be VariableElement, (FIXME: warning when it is checked for metadata of VariableElement it threw catchable error - it is about when metadata had no .last element - it must but possibly internal problem. see how i wrote the code not to throw - check if metadata.length > 0 and don't use .last for now)
      // we have computeConstantValue (DartObject or null if failed) - we have two options check if two DartObject's are == equal
      // #If it is not that simple# we can still evaluate them to toBoolValue, but also toListValue so the only way we could use Lists.
      // Also works with custom objects like a custom class instance.
      // How a DartObject compares to another DartObject == ?
      // SUCCESS for complicated const instances!!!
      // it compares it correctly as below where in main.dart we have method definition and comparing with first method param annotation @$(...) instance
      // methodOne3(@$(num, String, Null, $NOT, int, 5.3) abcd)
      // when you create constant like below only jack.methodOne3(oneDollar); is true as twoDollar has 5.2 as last element.
      //// the same like methodOne3 @$ annotation
      //const oneDollar = $(num, String, Null, $NOT, int, 5.3);
      //// ALMOST the same like methodOne3 @$ annotation - last element not 5.3 but 5.2
      //const twoDollar = $(num, String, Null, $NOT, int, 5.2);
      //// compare see lint message
      //jack.methodOne3(oneDollar); true
      //jack.methodOne3(twoDollar); false

      final List<ElementAnnotation>? metad =
          inv.argumentList.arguments.first.staticParameterElement?.metadata;
      DartObject? exampleDollarInstanceToCompare;

      if (metad != null &&
          metad.isNotEmpty &&
          metad.last.element?.displayName == "\$") {
        if (inv.argumentList.arguments.first.staticType == null) {
          // throw?
          // Alternative usage:
          //((inv.argumentList.arguments.first.staticParameterElement?.metadata.first.element?.declaration as ClassMember) as FieldDeclaration).fields.variables.first.initializer;
        }
        bool hasBeenExceptionForTheCurrentNode = false;
        if (inv.argumentList.arguments.first.staticParameterElement?.declaration
                .library ==
            null) {
          exampleDollarInstanceToCompare = metad.last.computeConstantValue();

          // throw?
        }
      }
      DartObject? computedMetaObject =
          metad?.last.computeConstantValue() as DartObject?;
      DartObject? computedMetaObject2 =
          metad?.last.computeConstantValue() as DartObject?;

      Expression? arg = inv.argumentList.arguments.first;
      addLintMessage(reporter, inv, errors.ErrorSeverity.WARNING,
          '''Param 1: Expression: but is it of any type?: ${() {
        return (arg is CommentReferableExpression
                ? 'CommentReferableExpression and ${arg is ConstructorReference ? 'ConstructorReference' : arg is PropertyAccess ? 'PropertyAccess' : 'none additional of interest'}'
                : 'It is not CommentReferableExpression with other related implementers/extenders') +
            '\n\n' +
            (arg is DoubleLiteral
                ? 'DoubleLiteral ${arg.value}'
                : arg is IntegerLiteral
                    ? 'IntegerLiteral ${arg.value}'
                    : arg is StringLiteral
                        ? 'StringLiteral value:  ${arg.stringValue}, # sort of:${arg is SimpleStringLiteral ? 'SimpleStringLiteral' : arg is StringInterpolation ? 'StringInterpolation ${arg.firstString} ${arg.lastString} ${() {
                            String data = 'Gathering some info: ';
                            for (int i = 0; i < arg.elements.length; i++) {
                              if (arg.elements[i] is InterpolationExpression) {
                                data +=
                                    'i:$i is InterpolationExpression: nothing like .value ${(arg.elements[i] as InterpolationExpression).expression} ${(arg.elements[i] as InterpolationExpression).expression.runtimeType}';
                              } else if (arg.elements[i]
                                  is InterpolationString) {
                                data +=
                                    'i:$i is InterpolationString: ${(arg.elements[i] as InterpolationString).value}';
                              } else {
                                data +=
                                    'i:$i is none: InterpolationExpression nor InterpolationString';
                              }
                            }
                            return data;
                          }()}' : 'none important here'}'
                        : arg is ListLiteral
                            ? 'ListLiteral ([Edit: String \'Some \$abc wer\' is seen \'Some \$abc wer\' so you can\'t convert it so the same with everything - no useful] ast so astNode - if you try to get an AstNode to compare then maybe == would work) ${arg.elements.first} ${arg.elements}'
                            : arg is Identifier
                                ? 'Identifier can\'t compute, but have something  ${arg.name}, ${arg.staticElement?.id}, ${arg.staticElement?.nonSynthetic.id} ${arg.staticElement?.declaration?.id}, ${arg.staticElement?.nonSynthetic.declaration?.id}, is VariableElement ${arg.staticElement is VariableElement}, has declaration VariableElement ${arg.staticElement?.declaration is VariableElement} computeConstantValue: ${() {
                                    var computedValue =
                                        (arg.staticElement as VariableElement)
                                            .computeConstantValue();
                                    String whattoreturn = arg.staticElement
                                            is VariableElement
                                        ? computedValue.toString()
                                        : 'not VariableElement so cannot compute.';

                                    whattoreturn +=
                                        'computed meta object - f.e. first param @\$(...) annotation of the called method\'s method declaration looks like this $computedMetaObject , How do two objects compare with == ? computedMetaObject == computedValue : ${computedMetaObject == computedValue} ${computedMetaObject == computedMetaObject2}';

                                    return whattoreturn;
                                  }()} ${() {
                                    if (arg.staticElement?.declaration
                                                ?.metadata !=
                                            null &&
                                        arg.staticElement!.declaration!.metadata
                                                .length >
                                            0) {
                                      return arg.staticElement!.declaration!
                                          .metadata[arg.staticElement!
                                              .declaration!.metadata.length -
                                          1];
                                    }
                                  }()}'
                                : 'nothing found');
      }()}''');
    });

    context.registry.addTopLevelVariableDeclaration(
        (TopLevelVariableDeclaration topLevelVariableDeclaration) {
      reporter.atNode(
          topLevelVariableDeclaration,
          LintCode(
            name: 'anno_types_warning',
            problemMessage:
                'addTopLevelVariableDeclaration, ${topLevelVariableDeclaration.declaredElement?.id} topLevelVariableDeclaration = ${topLevelVariableDeclaration.declaredElement?.declaration?.id} topLevelVariableDeclaration = ${topLevelVariableDeclaration}',
            errorSeverity: errors.ErrorSeverity.ERROR,
          ));
      //for (VariableDeclaration variableDeclaration
      //    in topLevelVariableDeclaration.variables.variables) {
      //  if (variableDeclaration.declaredElement?.nonSynthetic.id != null) {
      //    if (variableDeclarationsByElementId[
      //            variableDeclaration.declaredElement!.nonSynthetic.id] ==
      //        null) {
      //      variableDeclarationsByElementId[
      //          variableDeclaration.declaredElement!.nonSynthetic.id] = [];
      //    }
      //    variableDeclarationsByElementId[
      //            variableDeclaration.declaredElement!.nonSynthetic.id]!
      //        .add(variableDeclaration);
      //    addLintMessage(
      //        reporter,
      //        variableDeclaration,
      //        errors.ErrorSeverity.ERROR,
      //        'addVariableDeclaration, expression has been added: variableDeclaration.declaredElement!.id ${variableDeclaration.declaredElement!.id} variableDeclaration.declaredElement!.nonSynthetic.id ${variableDeclaration.declaredElement!.nonSynthetic.id}');
      //  } else {
      //    // diagnostic error message
      //    addLintMessage(
      //        reporter,
      //        variableDeclaration,
      //        errors.ErrorSeverity.ERROR,
      //        'addVariableDeclaration, variableDeclaration.declaredElement?.id == null which is unexpected situation');
      //  }
      //}
    });

    context.registry.addIdentifier((Identifier identifier) {
      addLintMessage(
          reporter,
          identifier.staticElement?.declaration,
          errors.ErrorSeverity.ERROR,
          'addIdentifier, expression has been added: identifier.staticElement?.id == ${identifier.staticElement?.id} identifier.staticElement?.declaration?.id == ${identifier.staticElement?.declaration?.id} identifier = $identifier');
    });

    context.registry
        .addVariableDeclaration((VariableDeclaration variableDeclaration) {
      if (variableDeclaration.declaredElement?.nonSynthetic.id != null) {
        if (variableDeclarationsByElementId[
                variableDeclaration.declaredElement!.nonSynthetic.id] ==
            null) {
          variableDeclarationsByElementId[
              variableDeclaration.declaredElement!.nonSynthetic.id] = [];
        }
        variableDeclarationsByElementId[
                variableDeclaration.declaredElement!.nonSynthetic.id]!
            .add(variableDeclaration);
        addLintMessage(reporter, variableDeclaration, errors.ErrorSeverity.INFO,
            'addVariableDeclaration, expression has been added: variableDeclaration.declaredElement!.id ${variableDeclaration.declaredElement!.id} variableDeclaration.declaredElement!.nonSynthetic.id ${variableDeclaration.declaredElement!.nonSynthetic.id}');
      } else {
        // diagnostic error message
        addLintMessage(
            reporter,
            variableDeclaration,
            errors.ErrorSeverity.ERROR,
            'addVariableDeclaration, variableDeclaration.declaredElement?.id == null which is unexpected situation');
      }
    });

    context.registry
        .addAssignmentExpression((AssignmentExpression assignmentExpression) {
      var readElement = assignmentExpression.readElement;
      var writeElement = assignmentExpression.writeElement;

      if (writeElement?.id != null) {
        if (assignmentExpressionsByElementId[writeElement!.id] == null) {
          assignmentExpressionsByElementId[writeElement.id] = [];
        }
        assignmentExpressionsByElementId[writeElement.id]!
            .add(assignmentExpression);
        addLintMessage(
            reporter,
            assignmentExpression,
            errors.ErrorSeverity.INFO,
            'addAssignmentExpression, expression has been added: writeElement?.id ${writeElement.nonSynthetic.id}, writeElement?.id ${writeElement.nonSynthetic.id} ');
      } else {
        // diagnostic error message
        addLintMessage(
            reporter,
            assignmentExpression,
            errors.ErrorSeverity.ERROR,
            'addAssignmentExpression, writeElement?.id == null which is unexpected situation');
      }

      if (readElement is LocalVariableElement) {
      } else if (readElement is ParameterElement) {
      } else if (readElement is ParameterElement) {}
      if (readElement != null) {
        reporter.atElement(
            readElement /*.parent!*/,
            LintCode(
                name: 'anno_types_warning',
                problemMessage: 'Here we are readElement',
                errorSeverity: errors.ErrorSeverity.WARNING));
      }
      if (writeElement is LocalVariableElement) {
      } else if (writeElement is ParameterElement) {}
      if (writeElement != null) {
        reporter.atElement(
            writeElement /*.parent!*/,
            LintCode(
                name: 'anno_types_warning',
                problemMessage:
                    'Here we are writeElement ${writeElement.metadata}',
                errorSeverity: errors.ErrorSeverity.WARNING));
      }

      /// MOST PROBABLY WE WONT IMPLEMENT VALUES BU TYPES IN EVERYTHING AS IT IS NOW.
      Identifier; // Expression as Identifier for method-invokation (the method's) invokation arguments .
      // .staticElement: The element associated with this identifier based on static type information,
      // if it is VariableElement i you can compute value, get declaration, isConst
      // you may try with LocalElement An element that can be (but is not required to be) defined within a method or function
      // ParameterElement probably implements both LocalElement and the mentioned VariableElement
      // You can try https://pub.dev/documentation/analyzer/6.8.0/dart_element_element/Element-class.html
      // if element is of any of the interfaces mentioned there on the page.
      // possibly could hope htat method(const [1, 2]) can be calculated as VariableElement or LocalElement - or not
      // but identifier method(identifierone) has greater chances to be resolved.
      //
      //[Edit: will be handled by a function/method:writeElement
      Expression; // can also be:
      ParenthesizedExpression; // .expression;
      ConditionalExpression; // probably including version "??"" and with .thenExpression, .elseExpression
      SwitchExpression; // .cases which are NodeList<SwitchExpressionCase> .expression for a case;

      //]

      Identifier;
      /*derived from*/ Expression;
      // the below is possibilities - maybe ListLiteral helps
      BooleanLiteral; // .value bool
      DoubleLiteral; // .value double
      IntegerLiteral; // similarly
      ListLiteral; // FIXME: - CANNOT COMPUTE, DOUBLE MAYBE EVEN STRING I COULD f.e. cannot compute value but have elements NodeList<CollectionElement> but cannot compute value of them
      NullLiteral;
      SetOrMapLiteral;
      RecordLiteral; // and more
      // now string literals
      StringLiteral; // .stringValue docs mentions both const settings but also null if the string isn't a constant string [?! the following:] without any string interpolation. May mean that string has no const features (not neccesary declared const), but if the string isn't const but has interpolation it is not null so looks like mistaken documentation because i would think of a string that cannot be const and can be const but without interpolation.
      // from StringLiteral
      SimpleStringLiteral;
      AdjacentStrings;
      StringInterpolation;
      addLintMessage(
          reporter,
          assignmentExpression,
          errors.ErrorSeverity.WARNING,
          'addAssignmentExpression, readElement?.id: ${readElement?.id}, writeElement?.id: ${writeElement?.id} writeElement?.nonSynthetic.id: ${writeElement?.nonSynthetic.id} leftHandSide: readElement.name ${readElement?.name} writeElement.name ${writeElement?.name} This is ExpressionFunctionBody assignmentExpression.leftHandSide.staticParameterElement: ${assignmentExpression.leftHandSide.staticParameterElement}, assignmentExpression.leftHandSide.unParenthesized.toString(): ${assignmentExpression.leftHandSide.unParenthesized.toString()}');
      addLintMessage(
          reporter,
          assignmentExpression,
          errors.ErrorSeverity.WARNING,
          'addAssignmentExpression, readElement?.id: ${readElement?.id}, writeElement?.id: ${writeElement?.id} writeElement?.nonSynthetic.id: ${writeElement?.nonSynthetic.id} rightHandSide: This is ExpressionFunctionBody assignmentExpression.rightHandSide.unParenthesized.toString() = ${assignmentExpression.rightHandSide.unParenthesized.toString()} ');
    });

    /// int is declaration id;
    Map<int, dynamic> functionLikeDeclarations = {};

    /// int is declaration id;
    Map<int, List<dynamic>> functionLikeInvocations = {};
    context.registry
        .addMethodDeclaration((MethodDeclaration methodDeclaration) {
      try {
        methodDeclaration.parameters?.parameterElements.first
            ?.computeConstantValue();
        if (methodDeclaration.declaredElement?.id != null) {
          functionLikeDeclarations[methodDeclaration.declaredElement!.id] =
              methodDeclaration;
        }
      } catch (e, stackTrace) {
        addLintMessage(
            reporter,
            methodDeclaration,
            errors.ErrorSeverity.WARNING,
            'addAssignmentExpression, e = $e, stackTrace = $stackTrace ');
      }
    });
    context.registry
        .addFunctionDeclaration((FunctionDeclaration functionDeclaration) {
      try {
        if (functionDeclaration.declaredElement?.id != null) {
          functionLikeDeclarations[functionDeclaration.declaredElement!.id] =
              functionDeclaration;
        }
      } catch (e, stackTrace) {
        addLintMessage(
            reporter,
            functionDeclaration,
            errors.ErrorSeverity.WARNING,
            'addAssignmentExpression, e = $e, stackTrace = $stackTrace ');
      }
    });
    context.registry
        .addFunctionExpression((FunctionExpression functionExpression) {
      try {
        if (functionExpression.declaredElement?.id != null) {
          functionLikeDeclarations[functionExpression.declaredElement!.id] =
              functionExpression;
        }
      } catch (e, stackTrace) {
        addLintMessage(
            reporter,
            functionExpression,
            errors.ErrorSeverity.WARNING,
            'addAssignmentExpression, e = $e, stackTrace = $stackTrace ');
      }
    });

    //List<FunctionExpressionInvocation> functionExpressionInvocations = [];

    //context.registry
    //    .addFunctionExpressionInvocation((FunctionExpressionInvocation inv) {
    //  addLintMessage(reporter, inv, errors.ErrorSeverity.ERROR,
    //      '''addFunctionExpressionInvocation: expression.runtimeType = ${inv.runtimeType}, inv == $inv''');
    //  functionExpressionInvocations.add(inv);
    //});

    // See the addMethodInvocation description above
    //context.registry.addMethodInvocation((MethodInvocation inv) {
    //  addLintMessage(reporter, inv, errors.ErrorSeverity.ERROR,
    //      '''addMethodInvocation: expression.runtimeType = ${inv.runtimeType}, inv == $inv inv.methodName.staticElement?.id = ${inv.methodName.staticElement?.id} inv.realTarget?.runtimeType == ${inv.realTarget?.runtimeType}''');
    //  try {
    //    if (inv.methodName.staticElement?.id != null) {
    //      if (functionLikeInvocations[inv.methodName.staticElement!.id] ==
    //          null) {
    //        functionLikeInvocations[inv.methodName.staticElement!.id] = [];
    //      }
    //      functionLikeInvocations[inv.methodName.staticElement!.id]!.add(inv);
    //    }
    //  } catch (e, stackTrace) {
    //    addLintMessage(reporter, inv, errors.ErrorSeverity.WARNING,
    //        'addAssignmentExpression, e = $e, stackTrace = $stackTrace ');
    //  }
    //});

    Map<int, Map<String, List<ParameterElement>>> pm = {};

    /// originally only for properties, however methods and constructors could be needed too
    Map<int, Declaration> classMembers = {};

    context.registry.addClassDeclaration((ClassDeclaration cd) {
      //classDeclaration.declaredElement?.allSupertypes;
      // FIXME: very ineficient way!! HAD NO CHOICE FOR NOW.
      var c = cd.members;
      int? id = cd.declaredElement?.id;
      for (int i = 0; i < c.length; i++) {
        Element? n = c[i].declaredElement;
        //addLintMessage(reporter, c[i], errors.ErrorSeverity.ERROR,
        //    '''addClassDeclaration: i = $i c[i].runtimeType = ${c[i].runtimeType}, c[i].declaredElement = ${c[i].declaredElement} c[i].declaredElement?.id == ${c[i].declaredElement?.id}''');
        //element and n.id was null for FieldDeclaration but not for its .fields
        //if (n?.id != null) {
        // this may be a declaration with couple of subdeclarations of variables
        //  classMembers[n!.id] = c[i];
        // try to break it down to subdeclaration
        if (c[i] is FieldDeclaration) {
          FieldDeclaration field = c[i] as FieldDeclaration;
          for (int k = 0; k < field.fields.variables.length; k++) {
            VariableDeclaration variable = field.fields.variables[k];
            if (variable.declaredElement?.id != null) {
              // FIXME: it is +1, to be compatible with other similar nubmers  this is increased.
              classMembers[variable.declaredElement!.id + 1] = variable;
            }
            //addLintMessage(reporter, variable, errors.ErrorSeverity.ERROR,
            //    '''addClassDeclaration: i = $i k = $k variable: field.fields.variables[k].runtimeType = ${field.fields.variables[k].runtimeType} field.fields.variables[k].declaredElement?.id = ${field.fields.variables[k].declaredElement?.id}''');
          }
          //}
        } else if (n?.id != null) {
          classMembers[n!.id] = c[i];
          addLintMessage(reporter, c[i], errors.ErrorSeverity.ERROR,
              '''addClassDeclaration: n!.id = ${n!.id} i = $i variable: c[i].runtimetype = ${c[i].runtimeType} c[i] = ${c[i]}''');
        }
        if (n is MethodElement && id != null) {
          String dn = n.displayName.replaceAllMapped(
              RegExp(r'^(?:.*?[\n\t\s\t]+)?([$_a-zA-Z]?[$_a-zA-Z\d]*)$',
                  multiLine: true),
              (m) => '${m.group(1)}');
          if (dn != '') {
            if (pm[id] == null) {
              pm[id] = {};
            }
            if (pm[id]![dn] == null) {
              pm[id]![dn] = [];
            }
            pm[id]![dn] = n.parameters;
          }
        }
      }
    });

    context.registry
        .addInvocationExpression((InvocationExpression invocationExpression) {
      addLintMessage(reporter, invocationExpression, errors.ErrorSeverity.ERROR,
          '''addInvocationExpression: expression.runtimeType = ${invocationExpression.runtimeType}, invocationExpression == $invocationExpression''');
      if (invocationExpression is MethodInvocation) {
        try {
          int? id = invocationExpression.methodName.staticElement?.id;
          if (id != null) {
            if (functionLikeInvocations[id] == null) {
              functionLikeInvocations[id] = [];
            }
            functionLikeInvocations[id]!.add(invocationExpression);
          }
          addLintMessage(
              reporter,
              invocationExpression,
              errors.ErrorSeverity.ERROR,
              '''some test message id = $id functionLikeInvocations.length == ${id != null ? functionLikeInvocations[id]?.length : null}
                  MethodInvocation would be declaration id idp = $id
                  inv.runtimeType = ${invocationExpression.runtimeType}
                  inv.function.runtimeType = ${invocationExpression.function.runtimeType}
                  is this needed?: (inv.function as Identifier).staticElement.runtimeType == ${invocationExpression.function is! Identifier ? null : (invocationExpression.function as Identifier).staticElement.runtimeType}
            ''');
        } catch (e, stackTrace) {
          addLintMessage(
              reporter,
              invocationExpression,
              errors.ErrorSeverity.WARNING,
              'addAssignmentExpression, e = $e, stackTrace = $stackTrace ');
        }
      } else if (invocationExpression is FunctionExpressionInvocation) {
        try {
          int? idp = invocationExpression.function is! Identifier
              ? null
              : (invocationExpression.function as Identifier).staticElement
                      is! VariableElement
                  ? null
                  : ((invocationExpression.function as Identifier).staticElement
                          as VariableElement)
                      .id;
          int? idp2 = invocationExpression.function is! Identifier
              ? null
              : (invocationExpression.function as Identifier).staticElement
                      is! TopLevelVariableElement
                  ? null
                  : ((invocationExpression.function as Identifier).staticElement
                          as TopLevelVariableElement)
                      .id;
          int? idp3 = invocationExpression.function is! Identifier
              ? null
              : (invocationExpression.function as Identifier).staticElement
                      is! LocalVariableElement
                  ? null
                  : ((invocationExpression.function as Identifier).staticElement
                          as LocalVariableElement)
                      .id;
          //var abc = (10 as PropertyAccessorElement).
          // FIXME: probably to be removed - in fact id5 correctly implements what idp4 was to do
          int? idp4 = invocationExpression.function is! Identifier
              ? null
              : (invocationExpression.function as Identifier).staticElement
                      is! PropertyAccessorElement
                  ? null
                  : ((invocationExpression.function as Identifier).staticElement
                          as PropertyAccessorElement)
                      .id;

          int? idp5 = invocationExpression.function is! PropertyAccess
              //FIXME: might be needed but commented for now: || (invocationExpression.function as PropertyAccess).propertyName.staticElement is! PropertyAccessorElement
              ? null
              : (invocationExpression.function as PropertyAccess)
                          .propertyName
                          .staticElement
                          ?.id ==
                      null
                  ? null
                  : (invocationExpression.function as PropertyAccess)
                      .propertyName
                      .staticElement
                      ?.id;

          final int? finalIdp = (idp ?? idp2 ?? idp3 ?? idp4 ?? idp5);
          if (finalIdp != null) {
            if (functionLikeInvocations[finalIdp] == null) {
              functionLikeInvocations[finalIdp] = [];
            }
            functionLikeInvocations[finalIdp]!.add(invocationExpression);
          }
          addLintMessage(
              reporter,
              invocationExpression,
              errors.ErrorSeverity.ERROR,
              '''some test message functionLikeInvocations.length == ${finalIdp != null ? functionLikeInvocations[finalIdp]?.length : null}
                  VariableElement idp = $idp
                  TopLevelVariableElement idp2 = $idp2
                  LocalVariableElement idp3 = $idp3
                  PropertyAccessorElement idp4 = $idp4
                  (invocationExpression.function is! PropertyAccess && function.propertyName.staticElement is PropertyAccessorElement) idp5 = $idp5
                  inv.runtimeType = ${invocationExpression.runtimeType}
                  inv.function.runtimeType = ${invocationExpression.function.runtimeType}
                  ${() {
            final function = invocationExpression.function;
            if (function is PropertyAccess) {
              //function.target?.runtimeType PropertyAccessorElement
              PropertyAccessorElement? staticElement;
              if (function.propertyName.staticElement
                  is PropertyAccessorElement) {
                staticElement = function.propertyName.staticElement
                    as PropertyAccessorElement;
              }
              String part = '';

              if (staticElement is PropertyAccessorElement) {
                part = '''
                staticElement.declaration.id = ${staticElement.declaration.id}  
                staticElement.correspondingGetter?.id = ${staticElement.correspondingGetter?.id}  
                staticElement.variable2?.getter?.id = ${staticElement.variable2?.getter?.id}
                staticElement.variable2?.computeConstantValue() = ${staticElement.variable2?.computeConstantValue()}
                staticElement.variable2?.computeConstantValue()?.toFunctionValue()? = ${staticElement.variable2?.computeConstantValue()?.toFunctionValue()}
                staticElement.variable2?.computeConstantValue()?.toFunctionValue()?.type.parameters = ${staticElement.variable2?.computeConstantValue()?.toFunctionValue()?.type.parameters}
                classMembers[idp5] = ${classMembers[idp5]}
                classMembers[idp5] is VariableDeclaration?(classMembers[idp5] as VariableDeclaration).initializer == ${classMembers[idp5] is VariableDeclaration ? (classMembers[idp5] as VariableDeclaration).initializer : null}
                ''';
              }

              return '''
                function.propertyName = ${function.propertyName}
                function.propertyName.name = ${function.propertyName.name}
                function.propertyName.staticElement.runtimeType = ${function.propertyName.staticElement.runtimeType}
                function.propertyName.staticElement = ${function.propertyName.staticElement}
                function.propertyName.staticElement?.id = ${function.propertyName.staticElement?.id}
                ${part}
                function.target.runtimeType = ${function.target?.runtimeType}
                function.target = ${function.target}
                function.realTarget.runtimeType = ${function.realTarget?.runtimeType}
                function.realTarget = ${function.realTarget}
                NEED ARGUMENTS TO THE CONSTRUCTOR
                ${() {
                if (true) {
                  String constructorExpressionInfo = '';

                  Expression? ultimateOnlyAssignmentExpression;
                  Expression findNonIdentifier(
                      Identifier ultimateOnlyAssignmentExpression) {
                    //int? containerClassId = function.realTarget is! Identifier
                    //    ? null
                    //    : (function.realTarget as Identifier)
                    //        .staticType
                    //        ?.element
                    //        ?.id;
                    //int? identifierDeclarationId =
                    //    function.realTarget is! Identifier
                    //        ? null
                    //        : (function.realTarget as Identifier)
                    //            .staticElement
                    //            ?.declaration
                    //            ?.id;

                    int? identifierId = function.realTarget is! Identifier
                        ? null
                        : (function.realTarget as Identifier).staticElement?.id;

                    List<VariableDeclaration>? variableDeclarations =
                        variableDeclarationsByElementId[identifierId];
                    List<AssignmentExpression>? assignmentExpressions =
                        assignmentExpressionsByElementId[identifierId];
                    Expression? ultimateOnlyAssignmentExpression;
                    if (variableDeclarations?.length == 1 &&
                        variableDeclarations!.first.initializer != null) {
                      if (assignmentExpressions != null &&
                          assignmentExpressions.length > 0) {
                        addLintMessage(
                            reporter,
                            invocationExpression,
                            errors.ErrorSeverity.ERROR,
                            'addAssignmentExpression, Declaration has initializer Expression but it can\'t be used because there is at least one non-declaration assignment - only one assigment can be allowed');
                      } else {
                        ultimateOnlyAssignmentExpression =
                            variableDeclarations!.first.initializer;
                        addLintMessage(
                            reporter,
                            invocationExpression,
                            errors.ErrorSeverity.ERROR,
                            'addAssignmentExpression #v1, ok: ultimateOnlyAssignmentExpression.rumtimeType = ${ultimateOnlyAssignmentExpression.runtimeType} ultimateOnlyAssignmentExpression = ${ultimateOnlyAssignmentExpression} if it is Identifer instance we will seek for non-identifier expression');
                      }
                    } else if (assignmentExpressions?.length == 1) {
                      if (variableDeclarations?.length == 1 &&
                          variableDeclarations!.first.initializer != null) {
                        addLintMessage(
                            reporter,
                            invocationExpression,
                            errors.ErrorSeverity.ERROR,
                            'addAssignmentExpression, There is one assigment to a Identifier/variable as expected but the the variable also have an initializer on it\'s variabledeclaration which is not allowed');
                      } else {
                        ultimateOnlyAssignmentExpression =
                            assignmentExpressions!.first.rightHandSide;
                        addLintMessage(
                            reporter,
                            invocationExpression,
                            errors.ErrorSeverity.ERROR,
                            'addAssignmentExpression #v2, ok: ultimateOnlyAssignmentExpression.rumtimeType = ${ultimateOnlyAssignmentExpression.runtimeType} ultimateOnlyAssignmentExpression = ${ultimateOnlyAssignmentExpression} if it is Identifer instance we will seek for non-identifier expression');
                      }
                    } else {
                      addLintMessage(
                          reporter,
                          invocationExpression,
                          errors.ErrorSeverity.ERROR,
                          'addAssignmentExpression #v2, no expression couldn\'t has been found.');
                    }

                    // btw: similar pattern used in some method in this file:
                    // we need constructor invocation expression abc() to get its function.propertyName.name argument
                    // which is expected to be Function expression
                    // the argument may be expression or identifier
                    // also only on value assignement is allowed - on declaration or (not and) on first-and-the-last assignment (dart will detect if using was before any first time value assignment - no need to check that)
                    // FIXME: ONE EXPRESSION IS REQUIRED F.E. INITIALIZER BECAUSE YOU HAVE ALWAYS ONE DECLARATION AND POSSIBLY SECOND IS ASSIGNMENT THIRD IS ERROR (SECOND IS ERROR IF VALUE WAS ASSIGNED ALREADY ON DECLARATION).
                    constructorExpressionInfo +=
                        ''' ${/*containerClassId = ${containerClassId}*/ ''}
                    identifierId = $identifierId ${/*identifierDeclarationId = ${identifierDeclarationId}*/ ''}
                    variableDeclarations.length = ${variableDeclarations?.length}
                    assignmentExpressions.length = ${assignmentExpressions?.length}
                    variableDeclarations = $variableDeclarations
                    assignmentExpressions = $assignmentExpressions
                  ''';

                    return ultimateOnlyAssignmentExpression is! Identifier
                        ? ultimateOnlyAssignmentExpression as Expression
                        : findNonIdentifier(ultimateOnlyAssignmentExpression);
                  }

                  ;
                  if (function.realTarget is Identifier) {
                    ultimateOnlyAssignmentExpression =
                        findNonIdentifier(function.realTarget as Identifier);
                  } else {
                    ultimateOnlyAssignmentExpression = function.realTarget;
                  }

                  constructorExpressionInfo += '''
                  ultimateOnlyAssignmentExpression = $ultimateOnlyAssignmentExpression
                  ultimateOnlyAssignmentExpression.runtimetype = ${ultimateOnlyAssignmentExpression.runtimeType}
                  ''';
                  bool haveWeFoundParamElement = false;
                  constructorExpressionInfo += '''
                        true: seeking seeking param: function.propertyName.name == ${function.propertyName.name}''';
                  Expression? constructorCorresponingArgument;
                  if (ultimateOnlyAssignmentExpression
                      is InstanceCreationExpression) {
                    for (Expression argument in ultimateOnlyAssignmentExpression
                        .argumentList.arguments) {
                      if (argument.staticParameterElement?.name ==
                          function.propertyName.name) {
                        constructorCorresponingArgument =
                            argument.unParenthesized is Identifier
                                ? findNonIdentifier(
                                    argument.unParenthesized as Identifier)
                                : argument.unParenthesized;

                        haveWeFoundParamElement = true;
                        constructorExpressionInfo += '''
                        true: argument.staticParameterElement?.name == function.propertyName.name, function.propertyName.name = ${function.propertyName.name}
                          haveWeFoundParamElement = ${haveWeFoundParamElement}
                          constructorCorresponingArgument = ${constructorCorresponingArgument}
                          constructorCorresponingArgument.runtimeType = ${constructorCorresponingArgument.runtimeType}
                        ''';
                      }
                    }
                  }
                  ;
                  return constructorExpressionInfo;
                }
              }()}
              ''';
            }
          }()}
                  (inv.function as Identifier).staticElement.runtimeType == ${invocationExpression.function is! Identifier ? null : (invocationExpression.function as Identifier).staticElement.runtimeType}
            ''');
        } catch (e, stackTrace) {
          addLintMessage(
              reporter,
              invocationExpression,
              errors.ErrorSeverity.ERROR,
              'addAssignmentExpression, e = $e, stackTrace = $stackTrace ');
        }
      }
    });
    context.addPostRunCallback(() {
      //for (List<ReturnStatement> value in returnStatements.values) {
      //  for (ReturnStatement statement in value) {
      //    addLintMessage(reporter,statement, errors.ErrorSeverity.WARNING,
      //        'addPostRunCallback: was called for this return statement');
      //  }
      //}
      for (int declarationId in functionLikeInvocations.keys) {
        for (final dynamic /*FunctionExpressionInvocation*/ inv
            in functionLikeInvocations[declarationId]!) {
          if (inv is MethodInvocation) {
          } else if (inv is! num) {}
          addLintMessage(reporter, inv, errors.ErrorSeverity.ERROR,
              '''some test message inv.runtimetype == ${inv.runtimeType}''');
          if (inv is FunctionExpressionInvocation) {
            try {
              //variableDeclarationsByElementId;
              //assignmentExpressionsByElementId;
              //var functionExpression = inv.function is FunctionExpression
              //    ? inv.function as FunctionExpression
              //    : null;

              //addLintMessage(reporter, inv, errors.ErrorSeverity.ERROR,
              //    '''context.addPostRunCallback() call declaration
              //    inv.function.staticElement.runtimeType = ${inv.function is! Identifier ? null : (inv.function as Identifier).staticElement.runtimeType},
              //    inv.function.staticElement = ${inv.function is! Identifier ? null : (inv.function as Identifier).staticElement}
              //    inv.function.runtimeType = ${inv.function.runtimeType}
              //    inv.function = ${inv.function} functionExpression?.declaredElement?.id = ${functionExpression?.declaredElement?.id}, ''');
              int? idp = inv.function is! Identifier
                  ? null
                  : (inv.function as Identifier).staticElement
                          is! VariableElement
                      ? null
                      : ((inv.function as Identifier).staticElement
                              as VariableElement)
                          .id;
              int? idp2 = inv.function is! Identifier
                  ? null
                  : (inv.function as Identifier).staticElement
                          is! TopLevelVariableElement
                      ? null
                      : ((inv.function as Identifier).staticElement
                              as TopLevelVariableElement)
                          .id;
              int? idp3 = inv.function is! Identifier
                  ? null
                  : (inv.function as Identifier).staticElement
                          is! LocalVariableElement
                      ? null
                      : ((inv.function as Identifier).staticElement
                              as LocalVariableElement)
                          .id;
              //var abc = (10 as PropertyAccessorElement).
              int? idp4 = inv.function is! Identifier
                  ? null
                  : (inv.function as Identifier).staticElement
                          is! PropertyAccessorElement
                      ? null
                      : ((inv.function as Identifier).staticElement
                              as PropertyAccessorElement)
                          .id;

              addLintMessage(reporter, inv, errors.ErrorSeverity.ERROR,
                  '''some test message:
                  VariableElement idp = $idp
                  TopLevelVariableElement idp2 = $idp2
                  LocalVariableElement idp3 = $idp3
                  PropertyAccessorElement idp4 = $idp4
                  inv.runtimeType = ${inv.runtimeType}
                  inv.function.runtimeType = ${inv.function.runtimeType}
                  (inv.function as Identifier).staticElement.runtimeType == ${inv.function is! Identifier ? null : (inv.function as Identifier).staticElement.runtimeType}
            ''');
              VariableDeclaration? currentVariableDeclaration;
              if (idp != null) {
                variableDeclarationsByElementId[idp]?.length == 1
                    ? variableDeclarationsByElementId[idp]!.first
                        as VariableDeclaration
                    : null;
              }
              addLintMessage(reporter, inv, errors.ErrorSeverity.ERROR,
                  '''some test message
                  currentVariableDeclaration = $currentVariableDeclaration ''');
              Expression? resultExpression = null;
              if (currentVariableDeclaration != null &&
                  currentVariableDeclaration is VariableDeclaration &&
                  (currentVariableDeclaration.isFinal ||
                      currentVariableDeclaration.isConst) &&
                  currentVariableDeclaration.initializer != null) {
                resultExpression = getUltimateNonIdentifierExpression(
                    reporter,
                    returnStatements,
                    assignmentExpressionsByElementId,
                    variableDeclarationsByElementId,
                    currentVariableDeclaration.initializer!.unParenthesized);
              }
              //sometest: ${inv.function is! Identifier ? null : (inv.function as Identifier).staticElement is! VariableElement ? null : ((inv.function as Identifier).staticElement as VariableElement).declaration.id}
              //sometest: ${inv.function is! Identifier ? null : (inv.function as Identifier).staticElement is! VariableElement ? null : ((inv.function as Identifier).staticElement as VariableElement).id}

              var msg = '''
            inv.function.runtimeType = ${inv.function.runtimeType} inv.function = ${inv.function} inv.function is Identifier = ${inv.function is Identifier}, resultExpression = $resultExpression, resultExpression.runtimeType = ${resultExpression.runtimeType}, 
            VariableElement idp = $idp
            TopLevelVariableElement idp2 = $idp2
            LocalVariableElement idp3 = $idp3
            runtimeType1: ${inv.function is! Identifier ? null : (inv.function as Identifier).staticElement is! VariableElement ? null : ((inv.function as Identifier).staticElement as VariableElement).runtimeType}
            runtimeType2: ${inv.function is! Identifier ? null : (inv.function as Identifier).staticElement is! VariableElement ? null : ((inv.function as Identifier).staticElement as VariableElement).declaration.runtimeType}
            assignmentExpressionsByElementId[idp] == ${idp != null ? assignmentExpressionsByElementId[idp] : null}
            variableDeclarationsByElementId[idp] == ${idp != null ? variableDeclarationsByElementId[idp] : null}
            ''';
              addLintMessage(reporter, inv, errors.ErrorSeverity.ERROR, msg);
            } catch (e) {
              addLintMessage(reporter, inv, errors.ErrorSeverity.ERROR,
                  'some error about addFunctionExpressionInvocation, e: $e');
              continue;
            }
            //try {
            //  int? idToAdd = inv.function is! Identifier
            //      ? null
            //      : (inv.function as Identifier).staticElement is! VariableElement
            //          ? null
            //          : ((inv.function as Identifier).staticElement
            //                  as VariableElement)
            //              .declaration
            //              .id;
            //  if (idToAdd == null) {
            //    return;
            //  } else {
            //    idToAdd++;
            //  }
            //  //if (inv.staticElement?.declaration.id != null) {
            //  if (functionLikeInvocations[idToAdd] == null) {
            //    functionLikeInvocations[idToAdd] = [];
            //  }
            //  functionLikeInvocations[idToAdd]!.add(inv);
            //  //}
            //} catch (e, stackTrace) {
            //  addLintMessage(reporter, inv, errors.ErrorSeverity.WARNING,
            //      'addAssignmentExpression, e = $e, stackTrace = $stackTrace ');
            //}
          }
        }
      }
///////
////
////
////
////
////

      for (dynamic id
          in functionLikeDeclarations.keys /*returnStatements.keys*/) {
        /// int is declaration id;
        //Map<int, dynamic> functionLikeDeclarations = {};

        /// int is declaration id;
        //Map<int, List<dynamic>> functionLikeInvocations = {};
        if (functionLikeDeclarations[id] is int) {
          continue;
        }

        addLintMessage(
            reporter,
            functionLikeDeclarations[id],
            errors.ErrorSeverity.ERROR,
            'context.addPostRunCallback() call declaration id = $id, functionLikeInvocations[id].length (null - no invocations found) = ${functionLikeInvocations[id]?.length} ');

        if (functionLikeInvocations[id] is List &&
            functionLikeInvocations[id]!.length > 0) {
          for (dynamic inv in functionLikeInvocations[id]!) {
            functionLikeInvocations[id];
            // one step at a time:
            // 1. we have meethod declaration params
            //  a: get each one by name
            //  b: for each check if it has a $ - if so take dartObject and Expression of the $
            //  c: get main expression of default value and main expression of method invokation argument o
            //  d: get ultimate expressions from the two ininital expressions and join them into one list
            //  e: call checkingReturnTypesAndValues() with expressions and $, also method declaration (which is not necessary but required in code that was initially designed to work in some narrower circumstances - "return value")
            //  f: DON'T FORGET OF topLevel... param

            // FIRST A.
            NodeList<FormalParameter>? parameters;
            var declaration = functionLikeDeclarations[id];
            if (declaration is MethodDeclaration) {
              parameters = declaration.parameters?.parameters;
            } else if (declaration is FunctionDeclaration) {
              parameters =
                  declaration.functionExpression.parameters?.parameters;
            } else if (declaration is FunctionExpression) {
              parameters = declaration.parameters?.parameters;
            }
          }
        }

        //handlingFunctionLikeDeclaration(functionLikeDeclarations[id]);
      }
    });
  }

  @override
  List<Fix> getFixes() => [];
}










































class $<T, U> implements Type {
  final bool is$ = true;
  final dynamic t1;
  final dynamic t2;
  final dynamic t3;
  final dynamic t4;
  final dynamic t5;
  final dynamic t6;
  final dynamic t7;
  final dynamic t8;
  final dynamic t9;
  final dynamic t10;
  final dynamic t11;
  final dynamic t12;
  final dynamic t13;
  final dynamic t14;
  final dynamic t15;
  final dynamic t16;
  final dynamic t17;
  final dynamic t18;
  final dynamic t19;
  final dynamic t20;
  final dynamic t21;
  final dynamic t22;
  final dynamic t23;
  final dynamic t24;
  final dynamic t25;
  final dynamic t26;
  final dynamic t27;
  final dynamic t28;
  final dynamic t29;
  final dynamic t30;
  final dynamic t31;
  final dynamic t32;
  final dynamic t33;
  final dynamic t34;
  final dynamic t35;
  final dynamic t36;
  final dynamic t37;
  final dynamic t38;
  final dynamic t39;
  final dynamic t40;
  final dynamic t41;
  final dynamic t42;
  final dynamic t43;
  final dynamic t44;
  final dynamic t45;
  final dynamic t46;
  final dynamic t47;
  final dynamic t48;
  final dynamic t49;
  final dynamic t50;
  final dynamic t51;
  final dynamic t52;
  final dynamic t53;
  final dynamic t54;
  final dynamic t55;
  final dynamic t56;
  final dynamic t57;
  final dynamic t58;
  final dynamic t59;
  final dynamic t60;
  final dynamic t61;
  final dynamic t62;
  final dynamic t63;
  final dynamic t64;
  final dynamic t65;
  final dynamic t66;
  final dynamic t67;
  final dynamic t68;
  final dynamic t69;
  final dynamic t70;
  final dynamic t71;
  final dynamic t72;
  final dynamic t73;
  final dynamic t74;
  final dynamic t75;
  final dynamic t76;
  final dynamic t77;
  final dynamic t78;
  final dynamic t79;
  final dynamic t80;
  final dynamic t81;
  final dynamic t82;
  final dynamic t83;
  final dynamic t84;
  final dynamic t85;
  final dynamic t86;
  final dynamic t87;
  final dynamic t88;
  final dynamic t89;
  final dynamic t90;
  final dynamic t91;
  final dynamic t92;
  final dynamic t93;
  final dynamic t94;
  final dynamic t95;
  final dynamic t96;
  final dynamic t97;
  final dynamic t98;
  final dynamic t99;
  final dynamic t100;
  const $([
    this.t1,
    this.t2,
    this.t3,
    this.t4,
    this.t5,
    this.t6,
    this.t7,
    this.t8,
    this.t9,
    this.t10,
    this.t11,
    this.t12,
    this.t13,
    this.t14,
    this.t15,
    this.t16,
    this.t17,
    this.t18,
    this.t19,
    this.t20,
    this.t21,
    this.t22,
    this.t23,
    this.t24,
    this.t25,
    this.t26,
    this.t27,
    this.t28,
    this.t29,
    this.t30,
    this.t31,
    this.t32,
    this.t33,
    this.t34,
    this.t35,
    this.t36,
    this.t37,
    this.t38,
    this.t39,
    this.t40,
    this.t41,
    this.t42,
    this.t43,
    this.t44,
    this.t45,
    this.t46,
    this.t47,
    this.t48,
    this.t49,
    this.t50,
    this.t51,
    this.t52,
    this.t53,
    this.t54,
    this.t55,
    this.t56,
    this.t57,
    this.t58,
    this.t59,
    this.t60,
    this.t61,
    this.t62,
    this.t63,
    this.t64,
    this.t65,
    this.t66,
    this.t67,
    this.t68,
    this.t69,
    this.t70,
    this.t71,
    this.t72,
    this.t73,
    this.t74,
    this.t75,
    this.t76,
    this.t77,
    this.t78,
    this.t79,
    this.t80,
    this.t81,
    this.t82,
    this.t83,
    this.t84,
    this.t85,
    this.t86,
    this.t87,
    this.t88,
    this.t89,
    this.t90,
    this.t91,
    this.t92,
    this.t93,
    this.t94,
    this.t95,
    this.t96,
    this.t97,
    this.t98,
    this.t99,
    this.t100,
  ]);

  methodabc() => null;
}

/// You can use this class like this:
/// $($IF......), $($IF()......),
/// but extending classes must call a constructor like this:
/// $($CUSTOMIFINSTANCE())
/// this is because i don't know any other way to get to know if it is the $IF super class also than by using getField('is$IF')?.toBoolValue();
/// The same for the $, $then, etc. and all will be related to the myCustomGetCustomLint method
/// Decided to implemented now - having no time because this $IF... feature may will not be implemented (it was mentioned by a core dart developer in 2022 or 2023) - it is not on the dart-team list to be implemented probably, but the union types themselves are on the list but couting from 2024 they may not arrive in the following year as it's been on the waiting like f.e. 7 years already.
/// WARNING! $IF... It could get even more verbose and not to match the real life scenario needs, and also never be implemented by this.
/// So the $IF... is really much reasonably.
/// The real life scenario - if an element has no null value then other must be null or not null
/// It may involve a couple of elements.
/// When possible vis custom_lint package in the future
/// then this value ready (means value of Type) solution will handle f.e. Strings - if a param is int or "Hello!"
/// [$IF] CAN BE EXTENDED.
/// and it is simple to get that no $ORTHEN is needed
/// FIRST GOES TYPES FOR THE PARAM
/// THEN A CONDITION $IF $THEN
/// OR A SEQUENCE OF CONDITIONS
/// Conditional: when before a param in a method declaration or constructor declaration the $ constructor or extending the $ class constructor:
/// @$($IF, int, $THEN, 'someParamName', NULL, 'Hello!')
/// @$($IF, int, $ANDIF 'someParamName2', String, $THEN, 'someParamName', NULL, 'Hello!')
/// @$(
///   $IF, int,
///   $ANDIF 'someParamName2', String,
///   $THEN, 'someParamName', NULL, 'Hello!'
///   $ANDTHEN 'someParamName3', int
/// )
/// It means when an invoked/called method/constructor is called with an int value then the param named 'someParamName' must have type null or be String "Hello"
/// (FIXME: Warning, values like "abc" are allowed but only types not values of certain types are implemented)
/// @$($IF, int, $THEN, 'someParamName', NULL, 'Hello!')
/// not used:If the type is not int when 'someParamName' must be null nor 'Hello!';
/// not used: @$($IF, int, $THEN, 'someParamName', NULL, 'Hello!')
/// If the type is not int when 'someParamName' can't be null nor 'Hello!';
/// And finally A FULL example of a sequence of conditions (just syntax - it doesn't need to be logical)
/// So bear in mind some conditions may be constradicting each other.
/// replaced by the changed syntax for not parts with $NOT: the old not valid example was: @$(int, 'Hello, hello' $IF, int, $THEN, 'someParamName', NULL, 'Hello!', $IFNOT, INT, $THENNOT, 'someParamName', NULL, 'Hello!')
/// ======================================
/// FIXME: FIXME IS USED TO TURN MY ATTENTION TO FOCUS AND TO REMIND ME NOT TO MISS SOMETHING DURING THE IMPLEMENTATION OF THIS ALL.
/// FIXME: TODO: UPDATE: CURRENT SYNTAX IS:
/// FIXME: because a t50 like proeprty can be null value which means it is not used,
/// then to ensure that an object can have the null value you have to use Null type instead - both for Type and instance/value that a  param is checked against
/// Remember - first if in a cycle is for the current method param it is applied for so no name is required
/// but if inside if is a condition that must be met for a different param (more ifs can be) so the name is reguired
/// then means what a different maybe some third or some four param must be or must NOT be if all related ifs are met.
/// $NOT switches further checking after it so that it means that the method/constructor param can't be of the types/values listed (of course if $IF is met it is instruction/condition not a regular type or value)
/// The situation the $NOT can be needed is if a tree stemming from a class is accepted
/// but you want to exclude some descending classes (or branches of descending classes)
/// or you want to exclude some values/instances of the class like you accept String, but it can't be "Hello".
/// Interesting thing noticed: Union Types with overloading methods (two or more declaration of a method with the same name)
/// is all you need.
/// But with condition $IF/$THEN overloading methods are in practice compeletely not needed.
/// FIXME: After fixing all the below problems START IMPLEMENTING $THEN because it is depending on the below.
/// FIXME: NOOOOOW! if before $NOT there is no type/value theParamMatchesAtLeastOneTypeOrValueRequirements ..2, ..3 stays fasle which causes error. but it should be true or think it over. See if it is correct for the opposite logic (?) of theParamMatchesAtLeastOneTypeOrValueRequirementsOf ...2, ...3
/// FIXME: THE third loop wrongly checks params NOT of the current invokation param but a different one.
/// FIXME: Seek this - there is some fixme/todo there - quite shouting piece of code: for (int t=0;t<inv.argumentList.arguments.length;t++)
/// TODO: [Edit: probably not needed - the generic type param definition like this: @$(int, String) T abc, but possibly useful in conditions but in very, very rare situations] Add handling generic types
/// TODO: Handle also return types with record return type, for example: (@$(num, String, Null, $NOT, int, 5.3) dynamic abc, int)? methodOne3... There is some path to do this in run() in context.registry.addReturnStatement body docs.
/// No num? is allowed, only num, Null, again: no null value is allowed - any null stops further params checking.
@$(
    // No num? is allowed, only num, Null, again: no null value is allowed - any null stops further params checking.
    num,
    Null,
    $NOT,
    int,
    $IF(
        num,
        $NOT,
        int,
        3.50,
        $IF('anotherMethodParam', Null),
        $IF('anotherMethodParam2', String, num, $NOT, int),
        $THEN('anotherMethodParam3', Null, String),
        $THEN('anotherMethodParam4', String, num, $NOT, int)),
    $IF(
        String,
        $NOT,
        $IF('anotherMethodParam', Null),
        $IF('anotherMethodParam2', String, num, $NOT, int, 5.20),
        $THEN('anotherMethodParam3', Null),
        // Another independent subcycle baset on thetop level $IF
        $IF('anotherMethodParam2', String, num, $NOT, int, 5.20),
        $THEN('anotherMethodParam4', String, num, $NOT, int, 2.20)))
class $IF {
  /// This property is because in static alalysis i don't know any other way to read if an extending class is also $IF descendant
  /// but the getField method of DartObject works.
  /// extending this base class could be implemented later. - see the important [myCustomGetCustomLint] method
  final bool is$IF = true;

  final dynamic t1;
  final dynamic t2;
  final dynamic t3;
  final dynamic t4;
  final dynamic t5;
  final dynamic t6;
  final dynamic t7;
  final dynamic t8;
  final dynamic t9;
  final dynamic t10;
  final dynamic t11;
  final dynamic t12;
  final dynamic t13;
  final dynamic t14;
  final dynamic t15;
  final dynamic t16;
  final dynamic t17;
  final dynamic t18;
  final dynamic t19;
  final dynamic t20;
  final dynamic t21;
  final dynamic t22;
  final dynamic t23;
  final dynamic t24;
  final dynamic t25;
  final dynamic t26;
  final dynamic t27;
  final dynamic t28;
  final dynamic t29;
  final dynamic t30;
  final dynamic t31;
  final dynamic t32;
  final dynamic t33;
  final dynamic t34;
  final dynamic t35;
  final dynamic t36;
  final dynamic t37;
  final dynamic t38;
  final dynamic t39;
  final dynamic t40;
  final dynamic t41;
  final dynamic t42;
  final dynamic t43;
  final dynamic t44;
  final dynamic t45;
  final dynamic t46;
  final dynamic t47;
  final dynamic t48;
  final dynamic t49;
  final dynamic t50;
  final dynamic t51;
  final dynamic t52;
  final dynamic t53;
  final dynamic t54;
  final dynamic t55;
  final dynamic t56;
  final dynamic t57;
  final dynamic t58;
  final dynamic t59;
  final dynamic t60;
  final dynamic t61;
  final dynamic t62;
  final dynamic t63;
  final dynamic t64;
  final dynamic t65;
  final dynamic t66;
  final dynamic t67;
  final dynamic t68;
  final dynamic t69;
  final dynamic t70;
  final dynamic t71;
  final dynamic t72;
  final dynamic t73;
  final dynamic t74;
  final dynamic t75;
  final dynamic t76;
  final dynamic t77;
  final dynamic t78;
  final dynamic t79;
  final dynamic t80;
  final dynamic t81;
  final dynamic t82;
  final dynamic t83;
  final dynamic t84;
  final dynamic t85;
  final dynamic t86;
  final dynamic t87;
  final dynamic t88;
  final dynamic t89;
  final dynamic t90;
  final dynamic t91;
  final dynamic t92;
  final dynamic t93;
  final dynamic t94;
  final dynamic t95;
  final dynamic t96;
  final dynamic t97;
  final dynamic t98;
  final dynamic t99;
  final dynamic t100;

  const $IF([
    this.t1,
    this.t2,
    this.t3,
    this.t4,
    this.t5,
    this.t6,
    this.t7,
    this.t8,
    this.t9,
    this.t10,
    this.t11,
    this.t12,
    this.t13,
    this.t14,
    this.t15,
    this.t16,
    this.t17,
    this.t18,
    this.t19,
    this.t20,
    this.t21,
    this.t22,
    this.t23,
    this.t24,
    this.t25,
    this.t26,
    this.t27,
    this.t28,
    this.t29,
    this.t30,
    this.t31,
    this.t32,
    this.t33,
    this.t34,
    this.t35,
    this.t36,
    this.t37,
    this.t38,
    this.t39,
    this.t40,
    this.t41,
    this.t42,
    this.t43,
    this.t44,
    this.t45,
    this.t46,
    this.t47,
    this.t48,
    this.t49,
    this.t50,
    this.t51,
    this.t52,
    this.t53,
    this.t54,
    this.t55,
    this.t56,
    this.t57,
    this.t58,
    this.t59,
    this.t60,
    this.t61,
    this.t62,
    this.t63,
    this.t64,
    this.t65,
    this.t66,
    this.t67,
    this.t68,
    this.t69,
    this.t70,
    this.t71,
    this.t72,
    this.t73,
    this.t74,
    this.t75,
    this.t76,
    this.t77,
    this.t78,
    this.t79,
    this.t80,
    this.t81,
    this.t82,
    this.t83,
    this.t84,
    this.t85,
    this.t86,
    this.t87,
    this.t88,
    this.t89,
    this.t90,
    this.t91,
    this.t92,
    this.t93,
    this.t94,
    this.t95,
    this.t96,
    this.t97,
    this.t98,
    this.t99,
    this.t100,
  ]);

  /// TODO: ALMOST CAN'T BE IMPLEMENTED BECAUSE dart_eval is in conflict with analyzer or custom lint
  /// used by the $IF function and   /// TODO: To be implemented later probably with the dart_eval package
  static ($AnnoTypesTypeOfLintReport lintReport, String lintMessage)?
      getCustomLintFor$IFCondition([
    initialDefaultEvaluation,
    /*Expression*/ dynamic paramNode,
    /*NodeList<Expression>*/ dynamic allParamNodes,
    // rather avoid using the following
    /*CustomLintResolver*/ dynamic resolver,
    /*ErrorReporter*/ dynamic reporter,
    /*CustomLintContext*/ dynamic context,
  ]) {
    print(true);
    return null;
  }

  /// TODO: To be implemented later probably with the dart_eval package
  /// like with the [$] - if returns null - ignored. if not null the returned value is more important than the default evaluation
  /// The default evaluation is in the first param initialDefaultEvaluation
  //final ($AnnoTypesTypeOfLintReport lintReport, String lintMessage)? Function() getCustomLint = myCustomGetCustomLint;

  void call() => null;
}

// Can only be used as a first parameter of @$($NOT, ...) annotation. not the same as is$IFNOT, etc. See $NOT, $IF, $ const classes.
final class $NOT {
  const $NOT();
}

class CUSTOMFANCYIFEXAMPLE extends $IF {
  const CUSTOMFANCYIFEXAMPLE();
}

// See the $IF description first then the $ - related to extending this class which has also to do with the is$THEN property but also [getCustomLint].
// like with the [$] - if returns null - ignored.
// This class and $THENNOT are not to be extended - to be used as is.
final class $THEN {
  /// This property is because in static alalysis i don't know any other way to read if an extending class is also $IF descendant
  /// but the getField method of DartObject works.
  /// extending this base class could be implemented later. - see the important [myCustomGetCustomLint] method
  final bool is$THEN = true;
  final dynamic t1;
  final dynamic t2;
  final dynamic t3;
  final dynamic t4;
  final dynamic t5;
  final dynamic t6;
  final dynamic t7;
  final dynamic t8;
  final dynamic t9;
  final dynamic t10;
  final dynamic t11;
  final dynamic t12;
  final dynamic t13;
  final dynamic t14;
  final dynamic t15;
  final dynamic t16;
  final dynamic t17;
  final dynamic t18;
  final dynamic t19;
  final dynamic t20;
  final dynamic t21;
  final dynamic t22;
  final dynamic t23;
  final dynamic t24;
  final dynamic t25;
  final dynamic t26;
  final dynamic t27;
  final dynamic t28;
  final dynamic t29;
  final dynamic t30;
  final dynamic t31;
  final dynamic t32;
  final dynamic t33;
  final dynamic t34;
  final dynamic t35;
  final dynamic t36;
  final dynamic t37;
  final dynamic t38;
  final dynamic t39;
  final dynamic t40;
  final dynamic t41;
  final dynamic t42;
  final dynamic t43;
  final dynamic t44;
  final dynamic t45;
  final dynamic t46;
  final dynamic t47;
  final dynamic t48;
  final dynamic t49;
  final dynamic t50;
  final dynamic t51;
  final dynamic t52;
  final dynamic t53;
  final dynamic t54;
  final dynamic t55;
  final dynamic t56;
  final dynamic t57;
  final dynamic t58;
  final dynamic t59;
  final dynamic t60;
  final dynamic t61;
  final dynamic t62;
  final dynamic t63;
  final dynamic t64;
  final dynamic t65;
  final dynamic t66;
  final dynamic t67;
  final dynamic t68;
  final dynamic t69;
  final dynamic t70;
  final dynamic t71;
  final dynamic t72;
  final dynamic t73;
  final dynamic t74;
  final dynamic t75;
  final dynamic t76;
  final dynamic t77;
  final dynamic t78;
  final dynamic t79;
  final dynamic t80;
  final dynamic t81;
  final dynamic t82;
  final dynamic t83;
  final dynamic t84;
  final dynamic t85;
  final dynamic t86;
  final dynamic t87;
  final dynamic t88;
  final dynamic t89;
  final dynamic t90;
  final dynamic t91;
  final dynamic t92;
  final dynamic t93;
  final dynamic t94;
  final dynamic t95;
  final dynamic t96;
  final dynamic t97;
  final dynamic t98;
  final dynamic t99;
  final dynamic t100;
  const $THEN([
    this.t1,
    this.t2,
    this.t3,
    this.t4,
    this.t5,
    this.t6,
    this.t7,
    this.t8,
    this.t9,
    this.t10,
    this.t11,
    this.t12,
    this.t13,
    this.t14,
    this.t15,
    this.t16,
    this.t17,
    this.t18,
    this.t19,
    this.t20,
    this.t21,
    this.t22,
    this.t23,
    this.t24,
    this.t25,
    this.t26,
    this.t27,
    this.t28,
    this.t29,
    this.t30,
    this.t31,
    this.t32,
    this.t33,
    this.t34,
    this.t35,
    this.t36,
    this.t37,
    this.t38,
    this.t39,
    this.t40,
    this.t41,
    this.t42,
    this.t43,
    this.t44,
    this.t45,
    this.t46,
    this.t47,
    this.t48,
    this.t49,
    this.t50,
    this.t51,
    this.t52,
    this.t53,
    this.t54,
    this.t55,
    this.t56,
    this.t57,
    this.t58,
    this.t59,
    this.t60,
    this.t61,
    this.t62,
    this.t63,
    this.t64,
    this.t65,
    this.t66,
    this.t67,
    this.t68,
    this.t69,
    this.t70,
    this.t71,
    this.t72,
    this.t73,
    this.t74,
    this.t75,
    this.t76,
    this.t77,
    this.t78,
    this.t79,
    this.t80,
    this.t81,
    this.t82,
    this.t83,
    this.t84,
    this.t85,
    this.t86,
    this.t87,
    this.t88,
    this.t89,
    this.t90,
    this.t91,
    this.t92,
    this.t93,
    this.t94,
    this.t95,
    this.t96,
    this.t97,
    this.t98,
    this.t99,
    this.t100,
  ]);

  /// TODO: ALMOST CAN'T BE IMPLEMENTED BECAUSE dart_eval is in conflict with analyzer or custom lint
  /// TODO: ALMOST CAN'T BE IMPLEMENTED BECAUSE dart_eval is in conflict with analyzer or custom lint
  /// like with $IF: /// TODO: To be implemented later probably with the dart_eval package
  // like with the [$] - if returns null - ignored. if not null the returned value is more important than the default evaluation
  /// The default evaluation is in the first param initialDefaultEvaluation
  /// TODO: ALMOST CAN'T BE IMPLEMENTED BECAUSE dart_eval is in conflict with analyzer or custom lint
  static ($AnnoTypesTypeOfLintReport lintReport, String lintMessage)?
      getCustomLintFor$THENCondition([
    initialDefaultEvaluation,
    /*Expression*/ dynamic paramNode,
    /*NodeList<Expression>*/ dynamic allParamNodes,
    // rather avoid using the following
    /*CustomLintResolver*/ dynamic resolver,
    /*ErrorReporter*/ dynamic reporter,
    /*CustomLintContext*/ dynamic context,
  ]) {
    print(true);
    return null;
  }
}

/// means mutable - $M is used for shorter syntax and by this readability
final class $M {
  final dynamic t1;

  /// This property is because in static alalysis i don't know any other way to read if an extending class is also $IF descendant
  /// but the getField method of DartObject works.
  /// extending this base class could be implemented later. - see the important [myCustomGetCustomLint] method
  final bool is$MUTABLE = true;

  const $M(this.t1);
}

/// Normally $(String, int, Null) - accepts "abc", 10, null, but $(String, $N(int)) accepts 1: 'abc', but 2: 10/null which is declared as variable with int? type
/// Warnin (Warning! think over/work it out: String? variable will value null will not pass in, only null of int? variable) - not flexible rarely useful as for the f.e. returned value to match it can't have just detected type int or Null but must be variable name that was declared exactly as int? and return 10 or null for example.
final class $N {
  final dynamic t1;

  /// This property is because in static alalysis i don't know any other way to read if an extending class is also $IF descendant
  /// but the getField method of DartObject works.
  /// extending this base class could be implemented later. - see the important [myCustomGetCustomLint] method
  final bool is$TypeOrNullType = true;

  const $N(this.t1);
}

/// means Regexp - A string expression will be matched against this regex
final class $R {
  final String t1; // source
  final bool t2; // multiline
  final bool t3; // case sensitive
  final bool t4; // unicode
  final bool t5; // isdotall

  /// This property is because in static alalysis i don't know any other way to read if an extending class is also $IF descendant
  /// but the getField method of DartObject works.
  /// extending this base class could be implemented later. - see the important [myCustomGetCustomLint] method
  final bool is$REGEX = true;

  const $R(this.t1,
      [this.t2 = false, this.t3 = true, this.t4 = false, this.t5 = false]);
}

/// means Between - An expression representing number will be checked if it is in the grater - less zone with including or not the left and right limit values
final class $B {
  final num t1; // left limit value
  final num t2; // right limit value
  final bool
      t3; // must be int-like (may be type double but integer - to enforce can't be double use f.e. @$(num $B(...) $NOT double))
  final bool t4; // includes left limit value
  final bool t5; // includes right limit value

  /// This property is because in static alalysis i don't know any other way to read if an extending class is also $IF descendant
  /// but the getField method of DartObject works.
  /// extending this base class could be implemented later. - see the important [myCustomGetCustomLint] method
  final bool is$Between = true;

  const $B(this.t1, this.t2, [this.t3 = false, this.t4 = true, this.t5 = true]);
}

enum $AnnoTypesTypeOfLintReport {
  NONE,
  INFO,
  WARNING,
  ERROR,
  COMPILATION_TIME_ERROR,
}

class Custom$ extends $ {}

sealed class UserType {
  const UserType();
}

final class UserTypeOne extends UserType {
  final abc;
  const UserTypeOne([this.abc = 10]);
}

final class UserTypeTwo extends UserType {
  const UserTypeTwo();
}

final class UserTypeThree extends UserType {
  const UserTypeThree();
}

class TestClass {
  final int a;
  // TODO: not implemented:
  // annotation means here an element must be String in normal instance creation,
  // but inside @$ when analyzed with danno_script $() instance is allowed f.e. @$(String, $R('a..d'))
  // also element annotated like here must be initialized directly in () bracket with no default value - simply this.b
  // ? however the element may not be passed as constructor param when null is allowed f.e.: @$(String, Null, $)
  @$(String, Null, $)
  final Object? b;

  const TestClass(this.a, this.b);
}

const someIntGlobal = 87;

class User {
  const User();

  static const int? someInt = 10;
  static const double? someDouble = 5.2;
  static const someString = 'some user instance string';
  static const someUserType = const UserTypeTwo();
  static const UserTypeOne? someUserTypeOne =
      UserTypeOne(UserTypeOne(UserTypeOne(12)));
  static const List<int>? someList = [10, 21];
  static const Map<int, String>? someMap = {10: "Abc", 21: "Cdef"};
  static const (int, String)? someRecord = (10, 'Rec');
  static const sourceOf$Instance = $(TestClass(1, 'abcdefsqqqhf21334233457'));
  static const correspondingSimpleValueForSourceOf$Instance =
      TestClass(1, 'abcdefsqqqhf21334233457');

  static const tretretretertert = $({'abe', 'erw'});
  static const sourceOf$InstanceRecord = $((2, tretretretertert));
  static const werwerwerwerwerwer = (2, ({'abe', 'erw'}));
  static const correspondingSimpleValueForSourceOf$InstanceRecord =
      (2, werwerwerwerwerwer);

  static const sourceOf$InstanceMap = $({'abc': 'cde'});
  static const correspondingSimpleValueForSourceOf$InstanceMap =
      (2, (2, ({'abc': 'cde'})));

  @$(
      num,
      TestClass,
      {'abc': (2, sourceOf$InstanceRecord)},
      $M({
        [
          1,
          $([6, $(double, 8)])
        ]
      }),
      List,
      {'wer', 'r'},
      $NOT,
      $M(TestClass(1, $('abcdefsqqqhf213342334571', $R('^a.*2\$')))),
      int,
      $M([
        1,
        $([6])
      ]),
      5.3,
      $M([2, 3]))
  methodOne4Simple(
      [@$(num, String, Null, $NOT, int, 5.3) abcd = someInt ??
          someInt ??
          (someInt == 10
              ? someInt
              : someInt == 10
                  ? (10, 'Some string.')
                  : null) ??
          345.43]) {
    return const {'abc': correspondingSimpleValueForSourceOf$InstanceRecord} ??
        5.8 ??
        {
          const [
            1,
            const [6, 8]
          ]
        } ??
        {
          const [
            1,
            const [6, 8.5]
          ]
        } ??
        {
          const [
            1,
            const [6, 9]
          ]
        } ??
        [
          1,
          const [6]
        ] ??
        TestClass(1, 'abcdefsqqqhf2133423345712') ??
        5 ??
        5.5 ??
        5.3 ??
        const {
          'abc': (2, (2, {'abe', 'erw'}))
        } ??
        () {
          return const {
            'abc': (2, (2, {'abe', 'erw'}))
          };
          return [2, 3];
        }();
  }
}

class tta {
  num methodw([asdf = 10]) => 10;
}

class tta2 extends tta {
  int methodw([asdf = 10]) => 10;
}

class ExampleConstComputableInvokationParam {
  final int abc = 10;
  const ExampleConstComputableInvokationParam();
}

int testfunction([int wre = 10]) {
  return 10;
}

class ExampleAAA {
  double b, c = 10.1, e = 20.2;
  int a = 10;
  final cde = ([int? a, String? b]) {};
  final Function cdeFromThis;
  static final cde2 = () {};
  static final cde3 = cde2;
  final cde4 = cde2;
  final ExampleAAA rfeChild = ExampleAAA();
  ExampleAAA(this.b, this.cdeFromThis);
}

abcderwerwr() {}

const asdfasdfadsfsfd = null;

final sdfsdfgdsgdsg = () {};

void main() {
  const int a = 10;
  var cde = User();
  cde.methodOne4Simple(10);
  abcderwerwr();

  sdfsdfgdsgdsg();
  () {}();

  var abcwqe;
  abcwqe = () {};
  abcwqe();
  //return;
  final abcwqe2 = () {};
  abcwqe2();
  abcwqe2();
  final abcwqe3 = () {};
  abcwqe3();
  abcwqe3();
  var rfe = ExampleAAA(10, (int abc, String cde) {
    return 10;
  });
  rfe.cde(); // rfe is SimpleIdentifier and Identifier
  rfe.rfeChild
      .cde(); // rfeChild is PrefixedIdentifier (and Identifier) so rfe. part will be the prefix and rfeChild has .identifier (SimpleIdentifier) and .prefix (SimpleIdentifier)
  //////

  rfe.cde(10, 'a');
  //
  //
  rfe.cde4();
  //
  //
  //
  ExampleAAA.cde2();
  ExampleAAA.cde3();
  var ertetr = rfe.cde;
  ertetr();
}
